# RailCore Engine Architecture - Comprehensive Technical Report

## Executive Summary

The RailCore engine abstraction implements a clean separation between UI and simulation logic through well-defined interfaces, dependency injection, and an observer pattern for state change notifications. The architecture supports pluggable implementations with comprehensive type safety and thread-safe operation.

---

## 1. INTERFACE DESIGN

### IRailEngine Interface

**Location**: `include/railcore/engine.h`

**Core Methods** (8 virtual functions):
- `LoadLayout(LayoutDescriptor)` - Initialize simulation from RCD file
- `Advance(milliseconds)` - Step simulation forward
- `Reset()` - Return to idle state
- `Command(CommandPayload)` - Execute user actions
- `GetSnapshot()` - Retrieve current world state
- `GetLayoutId()` - Get layout SHA-256 identifier
- `Subscribe(IObserver*)` - Register state change observer
- `Unsubscribe(IObserver*)` - Unregister observer

### Five Service Interfaces

All optional (nullptr-safe), dependency injected:

1. **ILayoutRepository** - Load/save RCD files
2. **ITelemetry** - Metrics and diagnostics
3. **IPersistence** - Save/restore game state
4. **IClock** - Time source abstraction
5. **IRandomProvider** - Deterministic randomness

### IObserver Pattern

**Three-channel notifications**:
- `OnSnapshot(WorldState)` - Full state updates
- `OnEvents(DomainEvent[])` - Discrete events
- `OnDiagnostics(string)` - Debug information

---

## 2. TYPE SYSTEM

### WorldState (Immutable Snapshot)

```cpp
struct WorldState {
  std::vector<Section> sections;
  std::vector<Route> routes;
  std::vector<Loco> locos;
  std::vector<TimetableEntry> timetable;
  std::vector<Assignment> assignments;
  DelaySettings currentDelay;
  SimulationClock clock;
  bool simulationActive;
  uint32_t tickId;
};
```

Shared via `shared_ptr<const WorldState>` for efficient immutability.

### WorldDelta (Incremental Updates)

```cpp
struct WorldDelta {
  std::vector<EntityDelta> changes;
  SimulationClock clock;
  uint32_t tickId;
};

struct EntityDelta {
  int timetableId;
  std::optional<int> status;
  std::optional<int> minutesLate;
  // ... other optional fields
};
```

Only changed fields included, optimizing UI updates.

### DomainEvent Types

```cpp
enum class EventType {
  TrainArrived,
  TrainDeparted,
  LocoAssigned,
  LocoReleased,
  DelayChanged
};
```

---

## 3. STATE MACHINE

```
Idle → LoadLayout() → Paused ↔ Running → Stop() → Stopped → Reset() → Idle
```

**Key Invariant**: No state_ shared_ptr until LoadLayout succeeds

### State Transitions

- **Idle → Paused**: LoadLayout validates and initializes WorldState
- **Paused ↔ Running**: Command(Pause/Resume) toggles simulation
- **Running → Stopped**: Stop() halts permanently
- **Stopped → Idle**: Reset() clears all state

---

## 4. SIMULATION LOOP (Advance Method)

### Algorithm (from engine_stub.cpp)

```cpp
Status Advance(std::chrono::milliseconds dt) {
  if (!inProgress_.exchange(true)) {
    // Re-entrancy guard
    return Status{Busy, "Advance already in progress"};
  }

  std::unique_lock<std::mutex> lock(mu_);

  // Track elapsed time per assignment
  for (auto& assignment : state_->assignments) {
    assignment.elapsedMs += dt.count();

    // Generate events at milestones
    if (assignment.elapsedMs >= 200 && !firedArrival[assignment.timetableId]) {
      events.push_back(DomainEvent{TrainArrived, assignment.timetableId});
      firedArrival[assignment.timetableId] = true;
    }

    if (assignment.elapsedMs >= 500 && !firedDeparture[assignment.timetableId]) {
      events.push_back(DomainEvent{TrainDeparted, assignment.timetableId});
      firedDeparture[assignment.timetableId] = true;
    }

    // Compute 6 stage buckets (83.33ms each)
    int stageBucket = std::min(5, static_cast<int>(assignment.elapsedMs / 83));
    // Update stage telemetry...
  }

  WorldDelta delta;
  delta.changes = changes;
  delta.clock = state_->clock;
  delta.tickId = ++tickId_;

  lock.unlock();
  NotifyDelta(delta, events);

  inProgress_.store(false);
  return Ok();
}
```

**Key Features**:
- Re-entrancy protection via atomic flag
- Event generation at 200ms (arrival) and 500ms (departure)
- Stage telemetry computed every 83.33ms (6 buckets per 500ms cycle)
- Lock released before notifications (prevents deadlock)

---

## 5. COMMAND SYSTEM

### Command Pattern Implementation

Six command types via polymorphic CommandPayload:

1. **AssignLoco** - Assign locomotive to timetable entry
2. **ReleaseLoco** - Remove locomotive from service
3. **SetDelayMode** - Change delay simulation mode
4. **Pause** - Pause simulation
5. **Resume** - Resume simulation
6. **Stop** - Stop simulation permanently

### AssignLoco Workflow

```cpp
Status HandleAssignLoco(const AssignLocoPayload& cmd) {
  // Validate timetable entry exists
  if (!state_->timetable[cmd.timetableId]) {
    return Status{InvalidCommand, "Timetable entry not found"};
  }

  // Create assignment
  Assignment assignment;
  assignment.timetableId = cmd.timetableId;
  assignment.locoId = cmd.locoId;
  assignment.elapsedMs = 0;

  // Predict route from arrival selector
  assignment.route = PredictRoute(cmd.timetableId);

  state_->assignments.push_back(assignment);

  // Generate event
  events.push_back(DomainEvent{LocoAssigned, cmd.timetableId, cmd.locoId});

  return Ok();
}
```

---

## 6. RCD FILE FORMAT & VALIDATION

### Format Structure

9 INI-style sections:
- **[GENERAL]** - StartTime, StopTime
- **[SECTIONS]** - Track circuits (ID, X1-Y4)
- **[OVERLAPPING]** - Conflict pairs
- **[PLATFORMS]** - Station platforms
- **[SELECTOR]** - Signal/point controls
- **[ROUTES]** - Train paths with 6 stages
- **[LOCOS]** - Locomotive roster
- **[LOCOYARD]** - Yard configuration
- **[TIMETABLE]** - Train schedules

### Validation Rules

**ID Ranges**:
- Section: 1-999
- Route: 1-999
- Loco: 1-499
- Timetable: 1-499
- ArrSelector: 1-49 (input selectors only)

**Cross-References**:
- Route sections must exist in [SECTIONS]
- Timetable ArrSelector must exist in [SELECTOR]
- Overlap sections must exist in [SECTIONS]

**Layout ID**: SHA-256 hash of canonicalized content (64 lowercase hex)

---

## 7. DESIGN PATTERNS

### 1. Dependency Injection
```cpp
class RailEngineStub : public IRailEngine {
  std::unique_ptr<ILayoutRepository> repo_;
  std::unique_ptr<ITelemetry> telemetry_;
  // Injected via constructor
};
```

### 2. Observer Pattern
```cpp
std::vector<IObserver*> observers_;

void NotifySnapshot(const WorldState& state) {
  for (auto* observer : observers_) {
    observer->OnSnapshot(state);
  }
}
```

### 3. Command Pattern
```cpp
struct CommandPayload {
  CommandType type;
  variant<AssignLoco, ReleaseLoco, SetDelayMode, ...> data;
};
```

### 4. Factory Pattern
```cpp
std::unique_ptr<IRailEngine> CreateEngine(
  const EngineConfig& config,
  std::unique_ptr<ILayoutRepository> repo
);
```

### 5. State Pattern
```cpp
enum class EngineState {
  Idle, Paused, Running, Stopped
};
```

### 6. Immutable Snapshot Pattern
```cpp
std::shared_ptr<const WorldState> GetSnapshot() {
  return state_;  // Shared immutable pointer
}
```

### 7. Delta Pattern
```cpp
struct WorldDelta {
  std::vector<EntityDelta> changes;  // Only changed fields
};
```

### 8. Time-Stepped Simulation Pattern
```cpp
Status Advance(std::chrono::milliseconds dt) {
  // Deterministic time step
}
```

---

## 8. THREADING & CONCURRENCY

### Locking Strategy

- **Single std::mutex**: Coarse-grained locking for simplicity
- **Re-entrancy guard**: `inProgress_` atomic flag prevents nested Advance calls
- **Observer notification outside lock**: Prevents deadlock if observers call back

### Thread-Safe Immutable Snapshots

```cpp
std::shared_ptr<const WorldState> state_;
```

Observers receive shared pointers to immutable state—no locking needed for reads.

---

## 9. EXTENSION POINTS

### Custom Layout Repository
```cpp
class DatabaseRepository : public ILayoutRepository {
  Status Load(LayoutDescriptor& desc, WorldState& outState) override {
    // Load from database instead of file
  }
};
```

### Custom Telemetry Sink
```cpp
class CloudTelemetry : public ITelemetry {
  void RecordMetric(string name, double value) override {
    // Send to cloud metrics service
  }
};
```

### Custom Observer
```cpp
class CachingObserver : public IObserver {
  void OnSnapshot(const WorldState& state) override {
    // Cache for offline analysis
  }
};
```

---

## 10. ARCHITECTURAL STRENGTHS

1. **Clean Separation** - UI never touches simulation internals
2. **Testability** - All dependencies injectable, interfaces mockable
3. **Thread-Safe** - Single mutex, immutable snapshots
4. **Extensible** - Five service interfaces for customization
5. **Deterministic** - Time-stepped simulation, seeded random
6. **Observable** - Three-channel notification system
7. **Type-Safe** - Strong typing throughout, no void* or casts
8. **Modern C++** - shared_ptr, optional, variant, chrono

The RailCore engine architecture demonstrates **production-quality design** suitable for real-time simulation systems.
