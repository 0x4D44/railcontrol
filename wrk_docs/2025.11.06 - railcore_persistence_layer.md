# RailCore Persistence Layer - Comprehensive Technical Report

## Document Overview
- **Scope**: Complete analysis of RCD file format and persistence architecture
- **Coverage**: File format specification, data structures, validation, error handling, I/O patterns
- **Focus**: Understanding class hierarchy, data flow, and design patterns

---

## 1. CLASS HIERARCHY AND RELATIONSHIPS

### Core Interface Architecture

```
ILayoutRepository (abstract)
  └─ RcdLayoutRepository (concrete)
     └─ Status Load(LayoutDescriptor&, WorldState&)
```

**File**: `include/railcore/persistence/rcd_repository.h` (19 lines)

The repository interface uses the **Service Locator** pattern for dependency injection:

```cpp
class ILayoutRepository {
public:
  virtual ~ILayoutRepository() = default;
  virtual Status Load(LayoutDescriptor& desc, WorldState& outState) = 0;
};

class RcdLayoutRepository : public ILayoutRepository {
public:
  Status Load(LayoutDescriptor& desc, WorldState& outState) override;
};
```

### Input/Output Data Structures

**LayoutDescriptor** (bidirectional):
- `std::filesystem::path sourcePath` (input) - File location
- `std::string name` (input) - Layout name
- `std::string id` (output) - Computed SHA-256 hex identifier (64 chars)

**WorldState** (output only):
- `std::vector<Section> sections` - Track section definitions
- `std::vector<Route> routes` - Train routing rules
- `std::vector<Loco> locos` - Available locomotives
- `std::vector<TimetableEntry> timetable` - Train schedules
- `std::vector<Assignment> assignments` - Timetable-to-loco mappings
- `DelaySettings currentDelay` - Delay mode configuration
- `SimulationClock clock` - Simulation time state
- `bool simulationActive` - Paused/running state
- `uint32_t tickId` - Tick counter

### Entity Data Structures

**Section** (track unit):
```cpp
struct Section {
  uint32_t id;      // Range: 1-999, must be unique
  std::string name; // Display name
};
```

**Route** (train path through sections):
```cpp
struct Route {
  uint32_t id;                  // Range: 1-999, must be unique
  std::string name;
  uint32_t fromSelector{0};     // Starting selector ID
  uint32_t toSelector{0};       // Destination selector ID
  struct Stage {
    uint32_t primary{0};        // Primary section ID
    uint32_t secondary{0};      // Secondary (overlapping) section ID
  };
  Stage stages[6]{};            // Up to 6 routing stages
};
```

**Loco** (locomotive):
```cpp
struct Loco {
  uint32_t id;              // Range: 1-499
  std::string name;         // Stock designation
};
```

**TimetableEntry** (scheduled service):
```cpp
struct TimetableEntry {
  uint32_t id;              // Range: 1-499
  std::string name;         // Service name
  uint32_t arrSelector{0}; // Arrival selector (1-49 only)
};
```

---

## 2. RCD FILE FORMAT - COMPLETE SPECIFICATION

### Format Characteristics

- **Type**: Plain-text INI-style format
- **Data Format**: CSV (comma-separated values)
- **Line Endings**: CRLF or LF (both supported)
- **Encoding**: ASCII/UTF-8 compatible
- **Structure**: 9 required sections in defined order

### Section Specifications

#### [GENERAL] - Simulation Timing Control

**Format**:
```
StartTime = 0645
StopTime = 1155
```

**Validation**:
- REQUIRED: Both StartTime and StopTime must be present
- FORMAT: HHMM (hours 00-23, minutes 00-59)
- CONSTRAINT: StopTime > StartTime (strictly greater)
- FLEXIBILITY: Accepts both "Key=Value" and "Key, Value" syntax

**Data Type**: Stored as 4-digit integer (HHMM)

#### [SECTIONS] - Track Section Definitions

**Format**:
```
ID, X1, Y1, X2, Y2, X3, Y3, X4, Y4
```

**Fields**:
- ID: Section identifier (1-999)
- X1-Y4: Quadrilateral corner coordinates (integers)

**Validation**:
- ID Range: 1-999 (unsigned 32-bit)
- ID Uniqueness: Duplicate IDs rejected with error
- Token Count: Exactly 9 tokens
- Coordinate Type: All must be numeric

#### [ROUTES] - Train Route Definitions

**Format**:
```
ID, FromSelector, ToSelector, Stage1, Stage2, Stage3, Stage4, Stage5, Stage6
```

**Stage Encoding** (Special Feature):
- Values are compound integers: `primary + (secondary * 1000)`
- Example: `2003` decodes to Primary=3, Secondary=2
- Example: `56061` decodes to Primary=61, Secondary=56

**Validation**:
- ID Range: 1-999
- ID Uniqueness: Duplicate IDs rejected
- Token Count: Exactly 9 tokens (with whitespace repair fallback)
- FromSelector/ToSelector: Must exist in [SELECTOR] (or be 0)
- Stage Values: All section IDs must exist in [SECTIONS]

---

## 3. SHA-256 LAYOUT IDENTIFICATION SYSTEM

### Purpose and Usage

Provides **stable, unique identification** of RCD files for:
- Regression test baseline matching
- Layout versioning
- Content integrity verification
- Format compatibility tracking

### Algorithm Details

#### Canonicalization Algorithm

**Input**: Raw RCD file contents

**Process**:
1. **CR Removal**: Strip all `\r` characters (CRLF → LF)
2. **Per-Line Trimming**: Remove leading/trailing spaces and tabs
3. **Trailing Blank Removal**: Strip all blank lines at end
4. **Line Reconstruction**: Rebuild with LF endings

**Output**: Normalized string for hashing

**Stability Properties** (same ID despite):
- CRLF vs LF line endings
- Leading/trailing whitespace per line
- Trailing blank lines
- Tab vs space indentation

#### SHA-256 Computation

**Process**:
1. Schema tag prepended: `"rcd:v1\n"`
2. Canonical content appended
3. Input hashed with SHA-256
4. Output: 64-character lowercase hex string

**Cryptography Implementation**:
- API: Windows BCrypt (native OS crypto)
- Algorithm: BCRYPT_SHA256_ALGORITHM
- Output: 32 bytes (256 bits)
- Encoding: Lowercase hexadecimal

---

## 4. LOAD OPERATION DATA FLOW

### Phase 1: Path Resolution

**Algorithm**:
```
1. Check if sourcePath exists and is file
   YES → Use sourcePath
   NO  → Continue
2. Construct alternate path: parent_dir / "Game files" / filename
3. Check if alternate path exists
   YES → Use alternate path
   NO  → Return NotFound error
```

### Phase 2: File I/O

**Process**:
```cpp
std::ifstream in(srcPath, std::ios::binary);
std::ostringstream oss;
oss << in.rdbuf();
std::string contents = oss.str();

if (contents.empty())
  return Status{LayoutError, "Layout file is empty"};
```

### Phase 3: Content Normalization and Section Scanning

**Data Structures Used**:
```cpp
std::set<std::string> present;           // Sections seen
std::map<std::string,int> headerCounts;  // Occurrence per section
enum class Sec { None, General, Sections, ... } cur;  // Current section
```

### Phase 4: Structural Validation

**Checks**:
1. All 9 required sections present
2. Each section appears exactly once
3. Return detailed error on failure

### Phase 5: Data Parsing and Intermediate Collection

**Intermediate Structures**:
```cpp
std::set<uint32_t> sectionIds, routeIds, locoIds, ttIds, selectorIds;
std::map<uint32_t, RouteParsed> routeParsed;
std::vector<TTRef> ttRefs;
std::vector<OverlapRef> overlaps;
```

### Phase 6: Cross-Reference Validation

Validates all inter-entity references after collection completes.

### Phase 7: ID Computation

```cpp
std::string canon = CanonicalizeRcdContent(contents);
desc.id = ComputeRcdIdFromContent(canon, "rcd:v1");
```

### Phase 8: WorldState Population

Creates final WorldState structure from validated intermediate data.

---

## 5. COMPREHENSIVE VALIDATION MATRIX

### File-Level Validation

| Rule | Check | Error Code |
|------|-------|------------|
| File exists | sourcePath or fallback | NotFound |
| Readable | Open succeeds | LayoutError |
| Non-empty | Size > 0 | LayoutError |

### Structure Validation

| Rule | Requirement | Error Code |
|------|------------|------------|
| All sections | All 9 must be present | ValidationError |
| No duplicates | Each appears once | ValidationError |

### ID Range Validation

| Entity Type | Min | Max | Unique | Duplicate Handling |
|-------------|-----|-----|--------|-------------------|
| Section | 1 | 999 | YES | Reject with error |
| Platform | 1 | 999 | YES | Reject with error |
| Selector | 1 | 999 | YES | Reject with error |
| Route | 1 | 999 | YES | Reject with error |
| Loco | 1 | 499 | NO | Keep first, ignore rest |
| Timetable | 1 | 499 | NO | Keep first, ignore rest |

---

## 6. ERROR HANDLING AND STATUS CODES

### Status Code Enumeration

```cpp
enum class StatusCode {
  Ok,                // Operation succeeded
  InvalidCommand,    // Command/operation invalid
  LayoutError,       // File I/O or format error
  ValidationError,   // Data constraint violation
  NotFound,          // File not found
  Busy,             // Operation in progress
  InternalError,     // System/internal error
};

struct Status {
  StatusCode code;
  std::string message;
};
```

### Fail-Fast Strategy

Validation stops at **first error** encountered for clearer error messages and efficient processing.

---

## 7. DESIGN PATTERNS EMPLOYED

### 1. Service Locator / Dependency Injection
Constructor-based injection of interfaces for testability

### 2. Status/Result Pattern
Deterministic error handling without exceptions

### 3. Builder/Accumulator Pattern
Accumulate entities during parsing, validate after collection

### 4. Fallback Path Pattern
Try primary location first, graceful degradation to alternate paths

### 5. State Machine (implicit)
Parsing is stateful with current section tracking

---

## 8. INTEGRATION WITH RAIL ENGINE

### Loading Sequence

```cpp
Status LoadLayout(const LayoutDescriptor& desc) {
  std::unique_lock<std::mutex> lock(mu_);

  WorldState ws;
  LayoutDescriptor ld = desc;
  Status s = repo_->Load(ld, ws);
  if (s.code != StatusCode::Ok) return s;

  // Engine-level validation
  if (ws.locos.size() > config_.maxActiveTrains)
    return Status{ValidationError, "Active trains exceed max"};

  state_ = std::make_shared<WorldState>(std::move(ws));
  engineState_ = EngineState::Paused;
  layoutId_ = ld.id;

  NotifySnapshot();
  return Ok();
}
```

---

## 9. ARCHITECTURAL STRENGTHS

1. **Clear Separation of Concerns** - ID generation isolated, I/O separate from validation
2. **Comprehensive Validation** - Structure, entities, cross-references all verified
3. **Deterministic Error Handling** - Status-based returns, no exceptions
4. **Excellent Testability** - Interface-based design, mockable dependencies
5. **Backward Compatibility** - Graceful legacy format handling
6. **Stable Identification** - Whitespace-insensitive hashing

The RailCore persistence layer represents solid, professional software engineering with a balance between strictness and pragmatism.
