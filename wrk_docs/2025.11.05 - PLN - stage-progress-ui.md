# Stage Progress UI integration plan

## Goals
- Surface RailCore stage telemetry (`stage`, `stageIndex`, `stagePrimary`, `stageSecondary`) inside OWL Arrivals/Departures panes.
- Keep legacy simulation logic untouched for now; add an adapter path that accepts stage updates from the modern engine or other sources.
- Avoid regressions when stage data is absent (UI should continue showing legacy statuses only).

## Tasks
1. **Data plumbing inside UI layer**
   - Extend `TLayout` to store per-timetable stage telemetry (stage bucket, index, primary/secondary sections, progressMs).
   - Add getters that Arrivals/Departures panels can query; default to “unknown” when not populated.
   - Provide a setter API (e.g. `ApplyStageTelemetry(const StageTelemetryUpdate&)`) to be invoked by future controller/adapter code.

2. **Status rendering**
   - Update `TArrivals::TimeTabInfo` and `TDepartur::TimeTabInfo` to append a concise stage string when telemetry is available.
   - Example format: `Stage 2 (Sec 120 → Sec 400)` or `Stage 1 / bucket 3`. Use muted colours to avoid clashing with existing status colour-coding.
   - Ensure layout calculations (`TrackContent`) include the new text so auto-resize still works.

3. **Adapter stub**
   - Create a lightweight `StageTelemetryCache` class (no RailCore dependencies) that the future controller can feed from `SimulationTickResult` deltas.
   - Hook this cache into `TLayout` during `HandleTimeChange` or an explicit update call so UI refresh picks up the latest values.
   - For initial implementation, add an optional debug hook that derives stage data from legacy status transitions to validate the rendering path.
   - Proposed API sketch:
     - `struct StageTelemetryUpdate { int timetableId; int stage; int stageIndex; int stagePrimary; int stageSecondary; long progressMs; };`
     - `StageTelemetryCache::Queue(const StageTelemetryUpdate&)` accumulates the latest update per timetable; `ApplyPending(TLayout&)` flushes to `ApplyStageTelemetry` before legacy fallback runs; `Clear()` resets between ticks.
     - Cache may skip application when `GetStageTelemetry` already reports live data, ensuring the legacy fallback (`RefreshLegacyStageTelemetry`) only patches gaps.

4. **Future integration (follow-up)**
   - When the RailCore-backed controller is online, route `WorldDelta` timetable entries into the cache.
   - Consider displaying `stagePrimary`/`stageSecondary` as human-readable section names (look up via `PSectionInfo`).
   - Emit diagnostic logging when stage telemetry regresses (e.g., stage index decreases unexpectedly).

## Verification
- Manual smoke: ensure Arrivals/Departures still render without telemetry (release build). Toggle the debug hook to preview stage strings.
- Unit coverage: add small helper tests targeting the formatting logic (new pure functions for string assembly).
- Future: once controller feed exists, extend integration tests to simulate a tick and assert stage text updates.
