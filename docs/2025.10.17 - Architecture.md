# Rail Control Architecture

## Overview
- **Domain**: single-user Windows desktop simulation of a British-style rail control centre.
- **Technology stack**: Borland C++ 5.02 with OWLNext 6.30 (running in OWL1/2/5 compatibility), Win32 APIs (GDI, timers, multimedia sound, INI profile APIs), and legacy ctl3d custom control library.
- **Entry point**: `WinMain` in `RAILC.CPP` wires ctl3d registration, instantiates `TManager` (`TApplication`), and launches the `TMainWindow` frame.
- **Execution model**: single-threaded message loop. Simulation advances via a Win32 timer (`ID_TIMER`) that drives `TLayout::EvTimer`, which increments a half-minute clock and orchestrates state transitions.

## Runtime Context
- Runs on 32-bit Windows (targeted at Win32s/Windows 95 vintage APIs) with Borland runtime libraries.
- Relies on OWLNext headers/libs supplied alongside the project (`owlnx630/`) and ctl3d library (`CTL3D.LIB`).
- Uses WinHelp (`WinHelp`) and `sndPlaySound` for audio cues, so the target system must supply the legacy multimedia and help subsystems.
- Persistent configuration is stored in `RAILC.INI` alongside the executable; sample timetable/layout inputs live as `.RCD` text files in the repo root.

## Top-Level Components
| Layer | Component | Responsibility | Key Files |
|-------|-----------|----------------|-----------|
| Application shell | `TManager` / `TMainWindow` | Bootstraps UI chrome (toolbar, status bar, splash), manages menu commands, lifetime of child windows, and global settings/state flags (`GameInProgress`, `TimerSpeed`, etc.). | `RAILC.CPP`, `RAILC.H` |
| Simulation & rendering | `TLayout` (`TFrameWindow` child) | Core simulation engine and primary canvas. Owns geometry, timetable, locomotive, and routing datasets; handles timers, route validation, painting of layout/clock, and inter-window updates. | `LAYOUT.CPP`, `LAYOUT.H` |
| Data model | `TTimetable`, `TSection`, `TPlatData`, `TOverlapData`, `TRoutes`, `TLocos` | Encapsulate timetable entries, track sections, platform polygons, overlap pairs, route definitions, and locomotive metadata/flags. Arrays of these pointers are owned by `TLayout`. | `TIMETABL.*`, `SECTION.*`, `PLATDATA.*`, `OVLPDATA.*`, `ROUTES.*`, `LOCOS.*` |
| Status views | `TArrivals`, `TDepartur`, `TPlatform`, `TLocoyard` | Ancillary windows that render textual summaries of upcoming arrivals/departures, platform occupancy, and yard locomotive positions. They subscribe to parent fonts and are refreshed from `TLayout::HandleTimeChange`. | `ARRIVALS.*`, `DEPARTUR.*`, `PLATFORM.*`, `LOCOYARD.*` |
| UI chrome | `TToolbar`, `TToolbutton`, `TStatbar`, `TSelector` | Custom toolbar/status bar widgets and interactive selector buttons that send route-selection commands back into the layout. | `TOOLBAR.*`, `TOOLBUTT.*`, `STATBAR.*`, `SELECTOR.*` |
| Dialogs & misc | `TConfigur`, `TStart`, `TFinish`, `TStartup`, `TAbout` | Modal workflows for configuration, introductory text, shift summary, splash, and about box. | `CONFIGUR.*`, `START.*`, `FINISH.*`, `STARTUP.*`, `ABOUT.*` |

All components include `CLASSDEF.H`, which (1) sets OWL compatibility flags; (2) pulls in every project header; and (3) defines shared constants (menu IDs, selector types, status codes).

## Data & Resource Architecture
- **Simulation datasets**: `TLayout` maintains fixed-size pointer arrays for each entity type (e.g., `PSectionInfo[1000]`, `PTimetableInfo[500]`, `PLocosInfo[500]`). Allocation happens during data-file load; slots remain `NULL` otherwise. Lifetime is tied to the `TLayout` instance, which tears everything down in `ClearData()`.
- **Timetable/status semantics**: `WorkTime`/`StopTime` are stored as packed half-minutes (`hours*120 + minutes*2 + halfMinuteFlag`), enabling precise comparisons inside the state machine (`HandleTracking`, `TimeCheck`). Train progress is represented by integer status codes (`ST_*`) defined in `GENERAL.H`.
- **Route control**: `PSelectorInfo` mirrors interactive track switches. `RoutesSet[5]` records currently lined routes; `IsRouteValid` enforces exclusivity rules using `TRoutes::GetClear` and `TOverlapData`.
- **Input format**: `.RCD` files contain tagged sections (`[GENERAL]`, `[SECTIONS]`, `[OVERLAPPING]`, `[PLATFORMS]`, `[SELECTOR]`, `[ROUTES]`, `[LOCOS]`, `[LOCOYARD]`, `[TIMETABLE]`). `TLayout::ReadDataFile` streams each block, validates ranges/duplicates, and materializes the backing objects. Parse failures trigger message boxes and abort session start.
- **Resources**: Bitmaps (`HR_DIGITAL`, toolbar art, loco splash), icons, the WinHelp project, and an embedded `BEEP` sample are defined in `RESOURCE\railc.rc`. Fonts and GDI pens/brushes are created once in the main window and reused by children.

## Control & Interaction Flow
1. **Startup**: `TMainWindow::SetupWindow` loads persisted INI settings, instantiates toolbar/status/layout, shows a splash (`TStartup`), and optionally opens auxiliary windows.
2. **Session launch** (`CMMnuFilNew`): calls `TLayout::StartNew`, which clears prior state, seeds dummy timetable slots, reads the selected `.RCD`, and (on success) starts the timer, shows the `TStart` dialog, and marks the game “in progress”.
3. **Simulation tick**: `TLayout::EvTimer` throttles ticks per `TimerSpeed`, advances `WorkTime`, and calls `HandleTimeChange`. That routine refreshes the clock, recomputes expected arrivals/departures, advances the train state machine, updates selector enablement, repaints the main panel, notifies child windows, and optionally plays the embedded beep.
4. **User interaction**: `TSelector` windows capture mouse state, invoke `TLayout::HandleSelectors`, and ultimately call `IsRouteValid` before pushing route selections into `RoutesSet`. Toolbar buttons forward predefined menu commands back to `TMainWindow`.
5. **Shutdown**: When `WorkTime` reaches `StopTime`, `EvTimer` pauses the session, opens `TFinish` to show averages, and then issues a stop command to reset UI state. `TMainWindow::CanClose` persists window geometry and feature flags back to `RAILC.INI` if `SaveOnExit` is enabled.

## Cross-Cutting Concerns
- **Tracing**: Macros `TRC_NRM`/`TRC_DBG` (likely from legacy logging helpers) produce diagnostic output. `TLayout::StartNew` and `HandleTimeChange` add direct file logging to `ptrack_debug.log` in the repository root—this hard-coded path couples the binary to a writable location.
- **Error handling**: Parsing and resource failures are surfaced via modal message boxes. Most routines guard against out-of-range indices but assume well-formed configuration over time.
- **Performance**: The heavy simulation work occurs on each timer tick in the GUI thread. Large data sets will increase work per tick, so timer speeds that shrink the skip interval can impact responsiveness.
- **Memory management**: Manual ownership via raw pointers; every allocation is paired with explicit `delete` within `ClearData` to avoid leaks between sessions. Failure to read a data file early exits after calling `ClearData`, so partially-initialized arrays are released.
- **Sound/help dependencies**: Missing `BEEP` resource or WinHelp files degrade features but do not terminate the app, although help invocations rely on legacy `.HLP` viewers.

## Build & Deployment Pipeline
- **Toolchain**: `build.bat` assumes Borland C++ 5.02 at `C:\Apps\BC5` and OWLNext 6.30 at `C:\Apps\owlnx630`. Alternative batch files (`build_local.bat`, `build_simple.bat`, etc.) tweak include/library paths or skip OWL object rebuilds.
- **Project files**: `railc.mak` (Borland make), `link.rsp` (linker response), and multiple `BccW32*.cfg` variants configure compiler options. Resources compile through `brc32` (`RESOURCE\railc.rc` → `railc.res`).
- **Outputs**: Object files, `railc.exe`, and generated resources are expected to live in the repository root per project guidelines.

## Architectural Constraints & Observations
- Tight coupling via the monolithic `CLASSDEF.H` (and pervasive globals) makes translation units interdependent, which simplifies OWL porting but hinders modular builds.
- UI and simulation share a single thread; expensive work in `HandleTimeChange` can block repainting and input handling.
- The simulation relies on fixed-size arrays; exceeding hard-coded maxima (e.g., >499 locos/timetable entries) would require code changes.
- Modern Windows systems may lack ctl3d or WinHelp support by default—redistribution packages or shims are required for contemporary deployments.
- Logging to `c:\language\railcontrol\ptrack_debug.log` violates portability; consider gating or relocating this in future revisions.
