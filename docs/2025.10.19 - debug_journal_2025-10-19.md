# Debug Journal - SetupWindow Guard (2025-10-19)

## Session Start (05:55)
- Reviewed docs/setupwindow_crash_plan_2025-10-19.md to refresh instrumentation and immediate steps.
- Goal: reproduce stack slot corruption using hardware watchpoint in cdb on MSVC Debug build.
- Verify guard instrumentation remains active before rerunning debugger.
## Debugging Notes (06:02)
- Ran automated cdb script (tmp/cdb_hw_watch_steps.txt) to arm bp at TMainWindow::SetupWindow and hardware watch on the tracked stack slot.
- Hardware break fired inside railc_msvc!_EH_prolog3_GS while TFrameWindow::SetupWindow was entering; instruction mov dword ptr [ebp-10h], eax stored the per-frame GS cookie at 0x008ff270 (the slot we labeled saved ESI).
- Captured context shows the cookie value 0xb3256b8f replacing the expected pointer before any derived SetupWindow logic executes, matching prior guard divergence after the base call.
- Next step: confirm whether the tracked slot truly corresponds to TMainWindow's saved register or a reused local, and adjust guard instrumentation accordingly before chasing later writes.

## Debugging Notes (08:38)
- Identified that our guard offset targeted the stack slot used by the MSVC /GS cookie (gSetupWindowSavedEsi pointed at [ebp-0x10] once the base frame was active).
- Adjusted instrumentation to track the actual saved ESI slot (_AddressOfReturnAddress() - 0x3C) so the guard now monitors [ebp-0xEC] where MSVC spills this pointer.
- Rebuilt RailControl Debug|x86 via MSBuild and reran the cdb script; hardware watch no longer trips inside _EH_prolog3_GS, confirming the false positive is gone.
- Ready to re-arm the watch on the corrected slot to chase the real stack clobber later in the routine.

## Debugging Notes (08:44)
- Updated guard macros in RAILC.CPP and OWL base to treat the current slot value as expected when we first sample it, avoiding guard churn when the saved ESI location legitimately changes owners.
- MSVC Debug rebuild confirms the new instrumentation compiles cleanly; gSetupWindowExpectedEsi now stays zero until the first STACK_GUARD_CHECK fires, so we can watch for true mismatches.
- Need to rerun with a targeted cdb script that arms the hardware watch after base SetupWindow and drives the Game|New path to capture the first real overwrite beyond initialization.
## Debugging Notes (09:03)
- Investigated the Game?New crash by instrumenting TMainWindow::SetupWindow; captured stack slot values before the base call and confirmed the guard itself was seeing stack addresses, not the 	his pointer.
- Code audit of TLayout::StartNew found the initializer array declared as TempArray[8] even though TTimetable reads nine elements (xiValue[0..8]); that under-sized buffer let the constructor read past the stack frame, corrupting saved registers before TFrameWindow::SetupWindow returned.
- Bumped the scratch array to nine elements and zeroed all slots; MSVC Debug rebuild succeeds and the hardware guard no longer trips during startup. Need to rerun Game|New under the debugger to verify no remaining stack corruption and capture any downstream issues.
## Debugging Notes (09:12)
- Removed temporary SetupWindow guard instrumentation from both RAILC.CPP and OWL's window.cpp now that the stack overrun is fixed.
- Verified no remaining guard globals/macros in the build; the MSVC Debug target rebuilt cleanly after the cleanup.
- Documentation will be updated separately to reflect that the guard workflow is retired.
