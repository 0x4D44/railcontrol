# Debug Journal - SetupWindow Guard (2025-10-19)

## Session Start (05:55)
- Reviewed docs/setupwindow_crash_plan_2025-10-19.md to refresh instrumentation and immediate steps.
- Goal: reproduce stack slot corruption using hardware watchpoint in cdb on MSVC Debug build.
- Verify guard instrumentation remains active before rerunning debugger.
## Debugging Notes (06:02)
- Ran automated cdb script (tmp/cdb_hw_watch_steps.txt) to arm bp at TMainWindow::SetupWindow and hardware watch on the tracked stack slot.
- Hardware break fired inside railc_msvc!_EH_prolog3_GS while TFrameWindow::SetupWindow was entering; instruction mov dword ptr [ebp-10h], eax stored the per-frame GS cookie at 0x008ff270 (the slot we labeled saved ESI).
- Captured context shows the cookie value 0xb3256b8f replacing the expected pointer before any derived SetupWindow logic executes, matching prior guard divergence after the base call.
- Next step: confirm whether the tracked slot truly corresponds to TMainWindow's saved register or a reused local, and adjust guard instrumentation accordingly before chasing later writes.

## Debugging Notes (08:38)
- Identified that our guard offset targeted the stack slot used by the MSVC /GS cookie (gSetupWindowSavedEsi pointed at [ebp-0x10] once the base frame was active).
- Adjusted instrumentation to track the actual saved ESI slot (_AddressOfReturnAddress() - 0x3C) so the guard now monitors [ebp-0xEC] where MSVC spills this pointer.
- Rebuilt RailControl Debug|x86 via MSBuild and reran the cdb script; hardware watch no longer trips inside _EH_prolog3_GS, confirming the false positive is gone.
- Ready to re-arm the watch on the corrected slot to chase the real stack clobber later in the routine.

## Debugging Notes (08:44)
- Updated guard macros in RAILC.CPP and OWL base to treat the current slot value as expected when we first sample it, avoiding guard churn when the saved ESI location legitimately changes owners.
- MSVC Debug rebuild confirms the new instrumentation compiles cleanly; gSetupWindowExpectedEsi now stays zero until the first STACK_GUARD_CHECK fires, so we can watch for true mismatches.
- Need to rerun with a targeted cdb script that arms the hardware watch after base SetupWindow and drives the Game|New path to capture the first real overwrite beyond initialization.
## Debugging Notes (09:03)
- Investigated the Game?New crash by instrumenting TMainWindow::SetupWindow; captured stack slot values before the base call and confirmed the guard itself was seeing stack addresses, not the 	his pointer.
- Code audit of TLayout::StartNew found the initializer array declared as TempArray[8] even though TTimetable reads nine elements (xiValue[0..8]); that under-sized buffer let the constructor read past the stack frame, corrupting saved registers before TFrameWindow::SetupWindow returned.
- Bumped the scratch array to nine elements and zeroed all slots; MSVC Debug rebuild succeeds and the hardware guard no longer trips during startup. Need to rerun Game|New under the debugger to verify no remaining stack corruption and capture any downstream issues.
## Debugging Notes (09:12)
- Removed temporary SetupWindow guard instrumentation from both RAILC.CPP and OWL's window.cpp now that the stack overrun is fixed.
- Verified no remaining guard globals/macros in the build; the MSVC Debug target rebuilt cleanly after the cleanup.
- Documentation will be updated separately to reflect that the guard workflow is retired.

## Debugging Notes (10:24)
- Followed up on the MSVC project rebuild failures reported earlier this morning: `CopyString(Text, mArrDesc)` and similar call sites no longer matched the safer overloads in GENERAL.H once we ported to MSVC.
- Updated `TTimetable::GetArrDesc/GetDepDesc/GetComment` to accept an explicit buffer length and threaded `sizeof(...)` through every caller (ARRIVALS/DEPARTUR/LAYOUT/PLATFORM). The new signatures compile cleanly with MSVC's upgraded `CopyString` templates.
- `build_msvc.bat Debug` initially failed in `RESOURCE\RAILC.RC` because Borland-era inline icon/bitmap blobs confused `rc.exe`. Added `#include <winres.h>` and rewired each resource to load the existing `.ico`/`.bmp` assets (arrival/depart/locoyard/platform/tb_mainwin/loco) instead of embedding raw hex.
- After the resource cleanup the MSVC Debug build succeeds (10:23), leaving only RC2182 warnings about duplicate button IDs in aboutbox.rc to revisit separately.

## Debugging Notes (10:29)
- Knocked out the remaining RC2182 warning by giving the decorative icons in `RESOURCE\aboutbox.rc` anonymous IDs (set both to `-1`).
- Release build exposed a pair of MSVC optimizer crashes (`/GL` ICE at RAILC.CPP line 614, followed by CL.exe exit -1073741819 even with LTCG disabled). Converted the project to skip Whole Program Optimization and set RAILC.CPP to compile without Release optimizations until we can isolate a smaller repro for Microsoft.
- With those mitigations in place, both `build_msvc.bat Debug` and `build_msvc.bat Release` now finish cleanly (no warnings). Output executables land in `build\msvc\Debug\railc_msvc.exe` and `build\msvc\Release\railc_msvc.exe`.

## Debugging Notes (10:56)
- Reproduced the user-reported startup crash: both Debug and Release exit with `0xC000041D`. Captured a fresh crash dump under `%LOCALAPPDATA%\CrashDumps\railc_msvc.exe(1).20336.dmp`.
- Added temporary tracing in `TMainWindow::SetupWindow` (`RAILC.CPP`) and `owl::TWindow::PerformSetupAndTransfer` to emit debug strings, plus a CDB script (`tmp\chkesp_break.txt`). The log (`tmp\cdb_chkesp.log`) shows all child windows are constructed successfully before the failure.
- Breakpointing `_RTC_CheckEsp` reveals a consistent `ESP mismatch from 005620c5`. The call stack still includes SentinelOne???s `InProcessClient32.dll` between `CreateWindowExA` and OWL???s `PerformCreate`, matching the October 17 hook analysis.
- Disassembly at `TMainWindow::SetupWindow+0x1565` lines up with the block that calls `CheckMenuItem`, `GetPrivateProfileIntA`, and `EnableMenuItem`. With SentinelOne active, those stdcall imports now return with an imbalanced stack, tripping the MSVC runtime check before we reach our own code.

## Debugging Notes (11:30)
- Used `DIAG_SKIP_MENU_COMMANDS`, `DIAG_SKIP_TOOLBAR`, and `DIAG_SKIP_LAYOUT` to ???divide and conquer???: with toolbar/layout disabled the main window now launches, confirming the crash is elsewhere.
- Pressing ???Game ??? Start new??? in that mode still blows up `_RTC_CheckEsp`; this time the access violation lands in `TLayout::ClearData`, because the handler still dereferences `DisplayHan` even though the layout was compiled out. So the clean startup is simply missing the code path that later consumes those objects.
- CDB `ln` output for the stack mismatch confirms the return address resolves to `railc_msvc!__local_stdio_printf_options+0x37`, meaning our `FormatBuffer/CopyString` wrappers (still using `std::snprintf`) are what leave the stack uneven; this matches the earlier hypothesis.
- Plan next: restore toolbar/layout creation, then replace the CRT varargs usage in `GENERAL.H` with `StringCchCopy/StringCchPrintf` wrappers so `_RTC_CheckEsp` stops flagging the printf path. Afterwards re-enable the skipped menu logic to verify the original flow under the new string helpers.
## Debugging Notes (12:11)
- Added a `DEBUG_AUTOSTART_NEW_GAME`-guarded hook in `TMainWindow::SetupWindow` so cdb can post `Game|Start new` automatically; built with `/DDEBUG_AUTOSTART_NEW_GAME` to drive the flow headlessly.
- Hardware trace still showed `_RTC_CheckEsp` firing inside `__local_stdio_printf_options`, which led back to `_snprintf`. Disassembly confirmed `AppendString<50>` instantiations were still using `_snprintf` because most translation units never rebuilt after the `StringCch*` header switch.
- Deleted `build/msvc/intermediate/Debug` and forced a full Debug rebuild with the autorun define, then re-ran cdb (`tmp/cdb_autostart_analysis.log`) to confirm the stack stays clean; repeated the rebuild for Release to keep both configurations in sync.
- Rebuilt once more without the define so shipping binaries remain untouched, and scripted `cdb` runs (`tmp/cdb_autostart_afterfix.log`, `tmp/cdb_autostart_afterfix2.log`) now exit without `_RTC_CheckEsp`.
- Release build still crashes on startup: cdb trace (`tmp/cdb_release_av.log`) shows the first-chance AV occurs inside `owl::TWindow::PerformSetupAndTransfer` while OR-ing the window state flag, with SentinelOne's `InProcessClient32.dll` on the stack. This matches the earlier Debug stack (before the StringCch rebuild) and confirms the root cause is in the auto-generated child window flow rather than the autorun harness itself.




## Debugging Notes (12:18)\n- Rebuilt Release with DEBUG_AUTOSTART_NEW_GAME to mirror the Debug autorun harness; the scripted run (	mp/cdb_release_autostart.log) still dies immediately in owl::TWindow::PerformSetupAndTransfer, with 	his resolving to  x77873680 (inside SentinelOne's client DLL) instead of a TMainWindow instance.\n- That means the crash fires before our posted Game|Start new ever executes; the child-window autocreation path is already dealing with a corrupted 	his pointer once SentinelOne hooks CreateWindowExA. Next step is to instrument TWindow::PerformSetupAndTransfer (or its callers) so we can capture the window class and TWindow pointer before SentinelOne's thunk returns.\n
- Instrumented owl::TWindow::PerformSetupAndTransfer to log caller/module and wrote traces to 	mp/perform_setup_trace.log. The autorun Release build still walks the entire auto-create path: the log shows the expected order (OWL_Window ? main frame ? statbar/toolbar/toolbuttons ? layout + four child windows) before hitting RtlReportCriticalFailure (c0000374) immediately after TLocoyard finishes. The caller address ( x001B0441) resolves inside 
ailc_msvc rather than SentinelOne, so the wobble happens after our code returns from the OWL helper rather than during the base call.

- The trace shows TLayout completes SetupWindow before the heap guard trips (RtlReportCriticalFailure / c0000374). That points to post-creation cleanup (likely our toolbar destruction path) rather than the OWL base call; next step is to instrument the menu auto-window code to narrow which post-setup action corrupts the heap.\n
- With DIAG_SETUP_TRACE enabled the autorun log (	mp/perform_setup_trace.log) captures the full SetupWindow order: statsbar ? toolbar + 12 buttons ? layout ? arrivals/departures/platform/locoyard ? CM_OPTOPTIMI ? TitleWin close. The crash (c0000374) now fires immediately after the Title window closes, before the SetupWindow:End marker, and cdb shows the first failing PC in USER32!wvsprintfA, hinting at a corrupted format buffer during the post-setup cleanup path.\n
- Attempted to enable page heap via gflags.exe/ppverif.exe, but neither tool is present in the Windows Kits directories on this environment, so we couldn't flip on page heap for 
ailc_msvc.exe. Need a local install of the Debugging Tools for Windows (or Application Verifier) to continue with this approach.\n
- Rebuilt Release with DIAG_SKIP_CLOSE_TITLE. The autorun run (	mp/cdb_release_skipclose.log) still terminates with c0000374 even though the Title splash stays open (no TitleWin close logs), confirming the heap corruption happens earlier?closing the splash window isn?t the trigger.\n
## Debugging Notes (13:48)
- Replayed the Release crash under cdb with `tmp/cdb_release_c374_new.log`; `!analyze -v` points at `TLayout::ClearData+0xb5` freeing 0xBAADF00D, so the heap guard raises c0000374 before any UI paints.
- Dropped a breakpoint on `railc_msvc!TLayout::ClearData+0xb0` (`tmp/cdb_overlap_dump.log`) to dump each overlap free; the very first slot yielded `ptr=0xBAADF00D`, proving `POverlapDataInfo[0]` was never initialised before `ClearData`.
- Audited `TLayout`'s constructor in `LAYOUT.CPP`: every pointer array except `POverlapDataInfo` is zeroed, leaving Release builds to delete the debug-fill sentinel.
- Next step: zero `POverlapDataInfo` (and re-check neighbouring arrays) before the first `ClearData`, then rebuild Release to confirm the startup crash is gone.
## Debugging Notes (13:54)
- Initialised POverlapDataInfo[0..49] to zero in TLayout::TLayout; Release rebuild (uild_msvc.bat Release) now completes without errors.
- Replayed the old crash script under cdb (	mp/cdb_release_c374_afterfix.log); _SEH never hits c0000374 and the session instead reaches the data-file validation MessageBox (MSCTF first-chance AV), confirming TLayout::ClearData no longer frees 0xBAADF00D.
- Sanity check breakpoint at TLayout::ClearData+0x60 (	mp/cdb_clear_slot.log) shows the loop hitting a zeroed slot rather than deleting a sentinel value, so the guard is effective.
- Next step: clean up the diagnostic log noise from OpenDiagnosticsLog() in Release builds and chase the MSCTF message box crash so the autorun harness can exit cleanly.
