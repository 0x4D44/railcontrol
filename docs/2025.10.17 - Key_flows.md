# Rail Control Key Flows

## 1. Application Startup
1. `WinMain` registers ctl3d, constructs `TManager`, and runs the OWL message loop (`RAILC.CPP`).
2. `TManager::InitMainWindow` instantiates `TMainWindow`, which immediately shows a splash (`TStartup`) and configures menu/brush resources.
3. `TMainWindow::SetupWindow`:
   - Creates the status bar and toolbar (loading `TB_MAINWIN` bitmaps, wiring tool buttons to menu commands).
   - Instantiates `TLayout` as the main child view and seeds fonts/brushes/pens for reuse by all child windows.
   - Reads persisted geometry/configuration from `RAILC.INI`.
   - Conditionally opens Arrivals/Departures/Platforms/Locoyard panes based on the INI flags.

## 2. Starting a Simulation Session
1. User triggers “Start new” (menu ID `CM_MNUFILNEW` or toolbar button 1).
2. `TMainWindow::CMMnuFilNew`:
   - Stops any existing timer and calls `TLayout::StartNew`.
   - Decides whether to keep the Locoyard window enabled based on `LocoyardEnabled`.
3. `TLayout::StartNew`:
   - Resets selector state (`TSelector::Reset`), destroys previously allocated objects (`ClearData`), and reinitialises arrays (`IniVariables`).
   - Seeds 10 placeholder `TTimetable` objects in `PTrackLoco` for tracking active routes.
   - Calls `ReadDataFile` to parse the chosen `.RCD` file. Any validation failure triggers a modal error and aborts the start.
4. On success, `CMMnuFilNew`:
   - Marks `GameInProgress = TRUE`, ensures selector windows are sized (`SizeSelectors`), invalidates the layout view, and flips toolbar button availability (show “Pause”, enable “Stop”).
   - Refreshes optional child windows, displays the `TStart` dialog (showing `StartText[0..2]`), and arms the Windows timer (`SetTimer` with 100 ms period).

## 3. Timer Tick & Simulation Advance
1. Each timer message hits `TLayout::EvTimer`.
2. Skip counter logic maps the real-time cadence to half-minute increments based on `TimerSpeed` (slow/normal/fast).
3. When `SkipCount` reaches the threshold:
   - `WorkTime` is incremented; wrap to zero after 24 simulated hours (2880 half-minutes).
   - If `WorkTime >= StopTime`, the session is paused, `TFinish` runs to display averages, and a stop command resets the UI.
   - Otherwise `HandleTimeChange` executes the main update pipeline:
     - `DrawClock` repaints the digital clock and delay boxes.
     - `GetExpecteds` rebuilds the next-eight-arrivals list and marks entries that changed.
     - `HandleTracking` progresses train states, clears/reserves sections, and updates locomotives in light of route data.
     - `GetDepartures` refreshes the departures queue.
     - `UpdateSelectors` recalculates which selector toggles are enabled (considering arrival stock type, platform occupancy, overlap conflicts, etc.).
     - Dependent windows (`TArrivals`, `TDepartur`, `TPlatform`, `TLocoyard`) redraw if they are open.
     - Optional beep sound plays when `SoundEnable` is true.
4. At the end of each tick the status bar text is reset to “Ready”.

## 4. Route Selection Workflow
1. Operator clicks a selector button (`TSelector` instance) representing an entry/exit/holding point.
2. `TSelector::EvLButtonDown/Up` toggles `SelectCur` and sends the `CM_SELECT` command back to the layout window.
3. `TLayout::HandleSelectors` records the first pressed selector (`Selector1`), waits for a second, and then:
   - Ensures the pair forms a valid route via `IsRouteValid`, consulting `PRoutesInfo` and `POverlapDataInfo` to avoid conflicts.
   - Updates `RoutesSet` (indices of active routes) and, if invalid, writes “Invalid route” to the status bar.
   - Releases selectors (`TSelector::Release`) and recalculates availability through `UpdateSelectors`.
4. Subsequent ticks in `HandleTracking` detect newly set routes and move trains into “set to platform” status, clearing sections as they progress.

## 5. Locomotive Assignment & Yard Operations
1. When a timetable entry enters a state requiring motive power (`TimeCheck` during arrival handling):
   - `AssignLoco` attempts to attach a locomotive from the yard (`LocoyardLoco[16]`) or via `AssignYardLoco`.
   - Stock codes determine eligibility (e.g., electric multiple units bypass loco assignment).
2. If an operator manually selects a locomotive in the yard window:
   - `TLocoyard::EvLButtonDown` sets `InWhichLoco = TRUE` and forwards the selection to `TLayout::WhichLoco`.
   - `WhichLoco` associates the chosen locomotive with the pending route, updates loco flags (`LF_*`), and refreshes the yard display.
3. Refuelling is tracked through `TLocos::SetRefuelTime`; `HandleTracking` checks for completion on each tick and returns locomotives to the available pool when ready.

## 6. Ending a Shift
1. Shift duration is defined by `[GENERAL] StartTime`/`StopTime` in the data file.
2. When `WorkTime` reaches `StopTime`, `TLayout::EvTimer`:
   - Issues a pause command, opens `TFinish` to show statistics (`ArrDelay`, `DepDelay`, `ShiftLength`), and immediately sends `CM_MNUFISTOP`.
3. `TMainWindow::CMMnuFiStop` tears down timers, resets flags (`GameInProgress = FALSE`, `GamePaused = FALSE`), reverts toolbar button state, clears selectors, and redraws the layout with the idle locomotive splash screen.
4. On application exit (`WM_CLOSE` → `CanClose`), window positions and user preferences are written back to `RAILC.INI` when `SaveOnExit` is enabled.
