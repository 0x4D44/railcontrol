# Memory Guard Implementation Journal (Codex)

## 2025-10-19T00:00Z
- Pulled up `docs/2025.10.19 - memory_robustness_implementation_plan.md` to understand staged goals.
- Scanned repository for existing guard work: located new `DebugMemoryGuard` scaffolding, helper scripts, and INI/bootstrap hooks inside `RAILC.CPP`.
- Confirmed logging/minidump plumbing largely implemented but flagged CI lint coverage as a follow-up to double-check (later validated `dbghelp.dll` copying via build script).
- Identified `OWNERSHIP.H` (managed array scaffolding) present but not yet wired into gameplay modules.

## 2025-10-19T00:25Z
- Walked key modules (`RAILC.CPP`, `LAYOUT.CPP`, `LOCOS.*`) to verify guard bootstrap and RAII adoption; discovered `TManagedArray` already backs timetable & loco containers and `CopyBuffer` helpers replaced raw `CopyString`.
- Verified MSVC build script already copies `dbghelp.dll`; CI workflow still lacks guard gating lint step.
- Determined next focus: implement Stage 1 lint (ensure guard headers excluded when `_MSC_VER` absent) before moving on to Stage 4 handle wrappers.

## 2025-10-19T01:05Z
- Added `tools\lint\memory_guard_stub.cpp` and `tools\lint_memory_guard.bat` so CI compiles the guard header with `_MSC_VER` undefined, guarding against regressions in non-MSVC builds.
- Wired the lint into `.github/workflows/msvc.yml`, documented it in `docs/development.md`, and verified the script runs successfully after relocating the stub into `tools\lint`.

## 2025-10-19T01:40Z
- Implemented `THandleGuard`/`TSharedHandle` infrastructure in `handleguard.h` and exposed it through `CLASSDEF.H` so app modules can adopt RAII handle semantics.
- Replaced manual GDI cleanup with guard-backed members in `TMainWindow`, `TLayout`, `TStartup`, `TToolbar`, and `TStatbar`, plus refreshed key drawing paths to rely on guards instead of raw `DeleteObject`/`DeleteDC`.
- Confirmed the guard lint (`tools\lint_memory_guard.bat`) still passes after the RAII conversions.

## 2025-10-19T02:10Z
- Extended the guard pattern into runtime rendering paths: clock/delay overlays now use `TReleaseDcGuard` + `TDcGuard`, and toolbar/toolbutton code no longer issues manual `DeleteDC` calls.
- Added `TReleaseDcGuard` helper for `GetDC` lifetimes and applied it where window DCs are fetched on demand.
- Re-ran `tools\lint_memory_guard.bat` to keep the Stage 1 lint green.

## 2025-10-19T02:35Z
- Applied the RAII wrappers to the loco yard, platform, and selector panes so every `GetDC`/`DeleteObject` pair moves through `TReleaseDcGuard` and the typed pen/font guards.
- Removed the legacy manual release logic from those modules, eliminating the remaining handle leak hot spots in the UI overlays.
- Confirmed `tools\lint_memory_guard.bat` still passes after the conversions.

## 2025-10-19T02:55Z
- Added `uihelpers.h` with `DrawRaisedPanel`/`FillRectOpaque` helpers, letting arrivals, departures, platform, and yard overlays share consistent framing + background fill code.
- Updated those modules to call the new helpers, trimming duplicate `CreatePen`/`ExtTextOut` blocks on top of the existing handle guards.
- Verified `tools\lint_memory_guard.bat` remains green after the refactor.

## 2025-10-19T03:10Z
- Extended the manual smoke checklist with a dedicated Memory Guard section covering status checks, log validation, and artefact collection.
- Ensured the documentation references `tools\enable_memory_guards.bat`, log/dump locations, and `collect_minidump.ps1` so QA can follow Stage 0 diagnostics during smoke runs.

## 2025-10-19T03:25Z
- Documented the shared UI helpers (`DrawRaisedPanel`, `FillRectOpaque`, `DrawHeaderLabels`) in `docs/development.md` so teams know where the common framing/backfill code resides.
- Re-ran `tools\lint_memory_guard.bat` to keep the guard lint green after the doc update.

## 2025-10-19T02:35Z
- Extended RAII coverage to the yard/platform/selector panes; all window DC fetches now flow through  while per-call pens/fonts use the guard aliases.
- Cleaned up legacy  branches, ensuring UI redraw paths across loco yard, platform, and selector modules no longer leak handles.
- Lint () stays green after the refactor.

## 2025-10-19T02:55Z
- Introduced  with shared / so arrival/departure/platform/yard panes share consistent framing and opaque fill logic.
- Updated those modules to use the helpers, trimming repeated / blocks on top of the existing handle guards.
- Lint () remains green after the helper refactor.

## 2025-10-19T03:25Z
- Documented the new UI helpers (, , ) in  so teams know where the shared framing code lives.
- Verified  still succeeds after the doc update.

## 2025-10-20T10:45Z
- Reattached cdb to the apparently hung `railc_msvc.exe`; main thread was sleeping inside `RtlSleepConditionVariableSRW` while `DebugMemoryGuard::GetState()` waited for static init to finish during the very first `operator new`.
- Found the re-entrancy culprit: `RecordAllocation`/`RecordFree` invoked `GetState()` before the `RecursionGuard` kicked in. The guard’s `unordered_map` construction re-entered `RecordAllocation`, hit `_Init_thread_wait_v2`, and deadlocked. Moved the guard check ahead of `GetState()` so re-entrancy now bails out immediately.
- Stubbed `StartupLog` to a no-op per divide-and-conquer. Debug build now starts cleanly and reproduces the original `_RTC_CheckEsp` inside `TMainWindow::SetupWindow`—hang resolved, ready to hunt the stack scribble.
- Next: instrument `SetupWindow` to binary-search the offending call sites.

## 2025-10-20T12:25Z
- Removed all temporary stack-probe macros and placement-new scaffolding from `RAILC.CPP`/`TOOLBAR.CPP`; constructor now uses standard `new TToolbar(...)` while keeping the managed-array cleanup.
- Rebuilt the Debug target and ran `cdb` with `_RTC` still enabled—no stack checks fired, and the process exited normally.
