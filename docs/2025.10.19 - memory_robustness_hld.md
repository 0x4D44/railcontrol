# Memory Robustness High-Level Design (2025-10-19)

## Context
- Historic crashes have come from stack corruption, double frees, and unchecked buffer copies inherited from the Borland/OWL codebase.
- Prior fixes relied on ad-hoc guard instrumentation that was difficult to maintain and did not scale to broader refactors.
- The shift to a modern MSVC build, along with planned refactors of layout, timetable, and UI subsystems, requires a formal memory-safety foundation that still supports the Borland toolchain.

## Goals
- Detect illegal heap usage (overruns, use-after-free, double delete) immediately during debug runs.
- Replace raw ownership patterns with deterministic RAII constructs while keeping OWLNext integrations intact.
- Reduce reliance on fixed-size C buffers by adopting length-aware helpers and STL containers where practical.
- Produce actionable diagnostics (logs, minidumps) that integrate with the existing manual smoke workflow and future automation.

## Non-Goals
- Migrating the application to Unicode or 64-bit during this phase.
- Replacing OWLNext with another UI framework.
- Depending on third-party allocators such as ASan runtimes.

## Proposed Architecture
### 1. Diagnostic Guard Layer
- Enable PageHeap and Windows Application Verifier during debug and CI runs (`gflags /p /enable railc_msvc.exe /full`, `appverif.exe /verify railc_msvc.exe`).
- Add a debug-only `DebugMemoryGuard` module that:
  - Wraps `operator new/delete` for MSVC builds (guarded by `#if defined(_MSC_VER)`) to tag allocations with call-site identifiers.
  - Writes structured guard events (timestamp, allocation id, size, callsite hash) to `%LOCALAPPDATA%\RailControl\Logs\memory_guard.log` with capped rotation (default 5 files x 2 MB).
  - Uses a thread-safe logging sink (critical section or SRW lock) so concurrent allocations cannot corrupt guard output.
  - Registers both `SetUnhandledExceptionFilter` and a vectored exception handler so guard logging occurs even when third-party code replaces the top-level filter, then calls `MiniDumpWriteDump` (ship matching `dbghelp.dll` if the target system needs it).
  - Publishes guard state over a lightweight status API (`DebugMemoryGuard::IsEnabled()`) and exposes INI toggles (`[Diagnostics] EnableMemoryGuards=1`) so QA can disable guards when measuring baseline performance.
- Restrict guard compilation to debug and diagnostic builds (`#if defined(_DEBUG) || defined(ENABLE_MEMORY_GUARDS)`), keeping release binaries free of additional hooks unless explicitly enabled.
- Provide helper scripts:
  - `tools\enable_memory_guards.bat` to toggle PageHeap and Application Verifier.
  - `tools\collect_minidump.ps1` to zip recent guard logs and dumps after a crash.

### 2. Ownership Abstraction Layer
- Introduce RAII helpers:
  - `THandleGuard` to wrap GDI, window, and menu handles with custom deleters.
  - `TObjectArray<T>` built on `std::vector<std::unique_ptr<T>>` to manage timetable and locomotive collections.
  - `TBuffer<N>` backed by `std::array<char, N>` that offers safe copy and format helpers.
  - Optional `TSharedHandle` wrapper for resources that OWLNext expects to outlive a parent window (reference-counted destroy semantics).
- Supply adapter shims (`Get()`, `data()`, `Release()`) so legacy OWL APIs still receive raw pointers without extra copies.
- Add targeted regression tests or assertions to confirm the wrappers respect OWLNext lifetime contracts, and document ownership transfer rules per wrapper in `docs/development.md`.
- Provide fallbacks (`#if !defined(_MSC_VER)`) that keep Borland-era pointer arrays in place until the toolchain migration is complete, and maintain a phase checklist identifying which modules have adopted the new wrappers so rollout progress stays visible.

### 3. Buffer and String Safety Layer
- Retire the legacy `CopyString` helpers in favour of `CopyBuffer(dest, destSize, src)` and `TBuffer<N>` so every caller provides an explicit capacity.
- Migrate high-risk structures (timetable fields, comments, INI values) to `std::string` or `owl::tstring` where API signatures allow it.
- Add debug-only boundary assertions (`RC_ASSERT(len < destSize)`) and route violations through the guard logging path.
- Provide compatibility shims so Borland builds continue to compile without pulling in STL-heavy helpers (conditionally compile modern code under `_MSC_VER`).
- Introduce fuzz-style data ingestion tests for `.RCD` files (Debug build only) that feed truncated and oversized inputs to the new helpers and ensure guard logging captures issues.

### 4. Toolchain Integration
- Update MSVC project defaults:
  - Debug: `/RTC1`, `/sdl`, `/guard:cf`, `_CRTDBG_MAP_ALLOC`, plus `_CrtSetDbgFlag` initialisation in `main`.
  - Release: `/Qspectre`, `/DYNAMICBASE`, `/guard:cf`, and an optional clang-cl configuration with `/fsanitize=address`.
- Keep Borland artefacts unchanged by limiting these switches to `.vcxproj` files and guarding new code with `#if defined(_MSC_VER)`.
- Document guard setup in `docs/development.md`, including quick-reference commands for enabling or disabling the diagnostics and expected warning output from PageHeap/AppVerifier.
- Add CI lint checks that ensure guard hooks remain opt-in for release builds (e.g., verify `_DEBUG` gating via scripted test) and fail the build if guard headers are consumed from non-MSVC configurations.

## Rollout Plan
1. **Phase 0 - Infrastructure**  
   Land `DebugMemoryGuard`, logging bootstrap, helper scripts, and documentation. Verify the Borland build remains clean.
2. **Phase 1 - Ownership**  
   Convert timetable and locomotive allocations to `TObjectArray` plus `std::unique_ptr`, add regression assertions, and run the manual smoke checklist.
3. **Phase 2 - Buffer Safety**  
   Replace `CopyString` call sites in layout and timetable paths, adopt `TBuffer`, and re-run smoke tests plus targeted file-load stress cases.
4. **Phase 3 - UI Resource Wrappers**  
   Wrap GDI and window assets with `THandleGuard`, audit window/timer lifecycle code, and validate the UI smoke checklist.
5. **Phase 4 - Hardening**  
   Enable PageHeap and Application Verifier in automated debug builds, publish a troubleshooting guide, and archive guard outputs nightly.
- Gate each phase behind sign-off covering MSVC Debug/Release and Borland builds to avoid cross-toolchain regressions.

## Risks and Mitigations
- **Performance overhead** from PageHeap and guards: default to Debug builds and allow opt-out via INI when gathering performance numbers.
- **Toolchain divergence**: guard modern code with `_MSC_VER` and add a CI smoke job that compiles under Borland to detect drift.
- **Refactor regressions**: roll out in phases, keep feature branches short, and archive guard logs and dumps for any new failures.
- **Dependency availability**: ship the required `dbghelp.dll` with guarded builds and document prerequisites for the diagnostic tooling (including minimum Windows SDK version for developers).
- **Legacy compatibility**: provide escape hatches (`EnableMemoryGuards=0`, `RAIITransition=Off`) so support teams can revert modules temporarily if a regression appears in production binaries.
- **Thread-safety regressions**: guard logging introduces shared state; mitigate by unit-testing concurrent allocation/free scenarios and exercising them in an automated stress harness.

## Validation
- Extend the manual smoke checklist with a "Memory Guard" section: enable guards, launch the Debug build, load each sample `.RCD`, run `Game -> New`, traverse key dialogs, exit cleanly, and confirm no guard alerts were recorded.
- Add a nightly scripted run under PageHeap that performs the same workflow and archives logs and dumps to `build\diagnostics\YYYYMMDD`.
- Record guard findings in the debugging journal so future regressions have historical context.
- Track unresolved guard alerts in an issue log and ensure each release milestone clears the list before promotion.
- Add a dedicated guard stress test (multi-threaded allocation churn) that validates log rotation and dump generation behave correctly under load.
