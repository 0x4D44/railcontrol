# Rail Control High-Level Design

## Purpose & Scope
This document outlines how the legacy Rail Control application is structured internally, the roles of its major subsystems, and the design choices that govern simulation behaviour, UI composition, and data management. It is intended to guide engineers who need to maintain, port, or extend the codebase.

## Architectural Principles
- **Simulate-first loop**: All gameplay logic runs inside `TLayout` and is driven by a deterministic tick (`HandleTimeChange`). UI surfaces pull their state from `TLayout` rather than maintaining their own copies.
- **Single ownership**: Each domain object (`TTimetable`, `TSection`, etc.) is owned by `TLayout`; ancillary windows only read through parent pointers. Lifetimes reset when a new data file is loaded.
- **Win32-first UI**: Custom drawing is handled manually with GDI. OWL provides window/message abstractions, but layout/painting remain imperative.
- **Configuration via text**: Layouts and timetables are data-driven through `.RCD` files, parsed section-by-section with defensive validation.
- **Legacy compatibility**: Code avoids OLE, COM, and modern Win32 features by design to preserve Borland 3.x/5.x compatibility.

## Module Responsibilities
### Application Shell (`RAILC.CPP` / `RAILC.H`)
- Sets up global resources (fonts, pens, brushes).
- Loads persisted settings (`GetPrivateProfileInt/String`) and writes them back on exit.
- Manages top-level commands (start, pause, stop, configure, help) and instantiates child frames on demand.
- Creates the toolbar/status bar and wires tool buttons to the same command handlers as menu items.

### Simulation Core (`LAYOUT.CPP` / `LAYOUT.H`)
- Maintains the authoritative model of the railway: sections, selectors, platforms, routes, locomotives, overlaps, and timetable rows.
- Provides lifecycle hooks:
  - `StartNew` → resets state, constructs placeholder track slots, invokes `ReadDataFile`.
  - `ClearData` → deletes every previously allocated object to avoid leaks.
  - `EvTimer` → throttles ticks based on `TimerSpeed`, increments `WorkTime`, and drives the main update loop.
  - `UpdateDisplay` / `Paint` → draws the schematic by scaling section coordinates to the current client rectangle.
- Implements domain behaviour through helpers:
  - **Timetable ingestion**: `ReadDataFile` populates arrays, cross-links selectors to platforms, sets initial statuses, and loads starting locomotives.
  - **Selector logic**: `HandleSelectors` and `UpdateSelectors` track pressed switches, validate candidate routes via `IsRouteValid`, and enforce constraints from `TOverlapData`.
  - **State machine**: `HandleTimeChange` orchestrates `GetExpecteds`, `TimeCheck`, `HandleTracking`, and `GetDepartures` to move trains through arrival, platform, and departure phases while accumulating performance metrics.
  - **Loco management**: `AssignLoco`, `AssignYardLoco`, and `LightLoco` attach motive power, honour refuelling rules, and keep the yard state coherent.

### Auxiliary Windows
- **Arrivals/Departures (`ARRIVALS.*`, `DEPARTUR.*`)**: Render tabular projections using offsets and fonts provided by `TMainWindow`. They rely on the parent `TLayout` for data and redraw flags (`ExpChng`, `DepChng`).
- **Platform status (`PLATFORM.*`)**: Keeps a snapshot of the most recently displayed strings so it can suppress unnecessary repaints.
- **Locoyard (`LOCOYARD.*`)**: Supports hit-testing locomotive icons and propagates selections back to `TLayout::WhichLoco` to fulfil route requirements.
- These windows are optional; menu/toolbar toggles instantiate or destroy them while persisting positions in `RAILC.INI`.

### UI Infrastructure
- **Toolbar/Buttons**: `TToolbar` materialises up to 20 `TToolbutton` children using bitmaps loaded from `TB_MAINWIN`. Each button posts commands directly to the target window (`SentWindow`) and updates the status bar through `SB_SETTEXT`.
- **Selectors**: `TSelector` is a `TFrameWindow` that behaves like a toggle button. It keeps the current vs. previous state, raises mouse events, and exposes metadata (`GetType`, `GetPlatRef`) so `TLayout` can interpret selections.
- **Status bar**: `TStatbar` manages its own font and repaints text written by menus, toolbar buttons, or the simulation loop.

### Dialog Workflows
- `TConfigur`: binds radio/check boxes to `TMainWindow` fields and applies changes immediately on `OK`.
- `TStart`: displays three lines of introductory text pulled from the `[GENERAL]` block of the data file.
- `TFinish`: computes and shows arrival/departure averages and qualitative ratings when a shift ends.
- `TStartup` and `TAbout`: purely visual, invoked on application launch or from the Help menu.

## Data Structures & Relationships
- **Sections vs. Platforms**: `TSection` holds polygon coordinates and occupancy. `TPlatData` references a `TSection` via matching indices and adds timetable/loco references plus a designated selector (`SelectorRef`).
- **Timetable**: `TTimetable` stores descriptions, arrival/departure points/times, stock codes, loco assignments, delay flags, and route numbers. Cross-links:
  - `GetRoute()` → index into `PRoutesInfo`.
  - `GetArrPnt()` / `GetDepTime()` → correlate with selectors and display ordering.
  - `SetStatus()` → drives state transitions consumed by UI and logic.
- **Routes**: `TRoutes::GetClear` returns section pairs that should be released at each phase of arrival/departure; this is central to `HandleTracking`.
- **Locos**: `TLocos` objects track class/number/type, assignment flag (`LF_*`), and refuel completion times. `LocoyardLoco[16]` lists yard occupants.
- Arrays in `TLayout` use 1-based indexes for compatibility with original code; bounds checks guard each block when parsing input.

## Simulation Pipeline
1. **Input parsing**: `ReadDataFile` walks the `.RCD` sections in a fixed order, validating range constraints and checking for duplicate IDs; failures abort the load after displaying a context-specific error text (strings 10000–10011 in resources).
2. **Initialization**: After loading, selectors are positioned, scaling factors reset, and `GetExpecteds`/`GetDepartures` prime their buffers.
3. **Tick cycle**:
   - Update calculated time displays (`DrawClock`).
   - Compute upcoming arrivals/departures; mark which entries changed so dependent windows know to repaint.
   - Advance train statuses via `TimeCheck` (pre-platform) and `HandleTracking` (infrastructure occupancy, release, and departure).
   - Reconcile locomotive assignments and shed/yard state.
   - Refresh UI children and optionally play the notification sound.
4. **Completion**: Upon reaching `StopTime`, run summary calculations, pause the timer, surface `TFinish`, and issue a stop command.

## Configuration & Persistence
- `RAILC.INI` sections:
  - `[Main Window]`: position, size, timer speed, boolean flags (save on exit, auto-optimize, delays enabled, sound, refuel), last used data file.
  - `[Arrival Window]`, `[Departure Window]`, `[Platform Window]`, `[Locoyard Window]`: presence and positions.
- On exit (`TMainWindow::CanClose`) and during option dialogs, values are read/written with Win32 profile APIs.
- Timetable metadata such as `StartText` lines and `WorkTime`/`StopTime` originate from the data file, not the INI.

## Extensibility Considerations
- **Adding new selectors/platforms/routes**: Requires updating the `.RCD` files within the current numeric limits. The C++ code already handles 1–49 selectors/platforms.
- **New UI panes**: Follow the pattern of deriving from `TFrameWindow`, requesting fonts from the parent, and exposing an `UpdateDisplay` method invoked from `HandleTimeChange`.
- **Modernisation**: A refactor to separate simulation from UI would involve extracting the state machine and data arrays from `TLayout` into pure-model classes, then exposing observer hooks for rendering.
- **Portability**: To port off Borland/OWL, replace `TApplication/TFrameWindow` usage with a modern framework (e.g., Qt, Win32 directly) while preserving the timer-driven loop and data structures.
- **Testing hooks**: Core logic is currently event driven; introducing unit tests would require wrapping `TLayout` operations in headless helpers that can drive `WorkTime` manually.

## Technical Risks & Debt
- Hard-coded debug logging (`ptrack_debug.log`) writes to an absolute path; this can fail in locked-down environments and should be optional.
- Manual memory management and pervasive C-style strings are error-prone; there is no guard against buffer overflows when copying descriptor text.
- The simulation loop assumes the UI thread remains responsive; heavy instrumentation or large datasets could cause frame drops.
- Lack of automated testing means behaviour regressions are only caught via manual smoke tests (load sample `.RCD`, exercise menus, press `F1` to launch WinHelp per project guidelines).
- WinHelp/ctl3d dependencies are deprecated on modern Windows releases, complicating redevelopment without shims.
