# Rail Control UI/Backend Split - High-Level Design
## 1. Purpose
- Establish a clear architectural boundary between the presentation layer (OWLNext UI) and core simulation logic so that the modernization effort can leverage MSVC/OWLNext while enabling automated testing and future UI evolutions.
- Preserve existing functionality and data artifacts (RCD layouts, WinHelp content) while improving maintainability, testability, and portability.
## 2. Scope
- Applies to new MSVC/OWLNext 7.x build; legacy Borland build remains only as a validation reference.
- Covers runtime components inside the executable, public/internal interfaces, and supporting build/test infrastructure.
- Excludes front-end visual redesign, data format changes, or deployment packaging.
## 3. Current State (17 Oct 2025)
- `TMainWindow` and `TLayout` own both rendering and business logic; global arrays (`PSectionInfo`, `PTimetableInfo`, etc.) are mutated directly from OWL event handlers.
- Timers, randomization, and file I/O are interwoven with UI classes, preventing headless execution.
- No cohesive module exposes the simulation state, making automated testing and alternative front ends difficult.
## 4. Design Goals
1. **Separation of Concerns** - UI handles input, rendering, and user affordances; backend handles simulation state, scheduling, and persistence.
2. **Testability** - Backend compiles into a static library (`railcore.lib`) with deterministic APIs suitable for GoogleTest/property tests.
3. **Determinism & Observability** - Backend surfaces explicit update ticks, logging hooks, and query APIs; UI subscribes via observers.
4. **Incremental Migration** - Enable phased refactors while maintaining a bootable application.
## 5. Proposed Architecture
### 5.1 Component Overview
| Component | Responsibility | Key Technologies |
| --- | --- | --- |
| **RailUI.exe** | Hosts OWLNext windows, menu handlers, dialogs, rendering surfaces, automation hooks. | OWLNext 7.x, Win32 GDI |
| **UI Adapter Layer** | Translates UI events into backend requests, marshals updates back to UI/stateful widgets. | C++17 interfaces, observer pattern |
| **RailCore (static lib)** | Deterministic simulation engine: layout parsing, timetable execution, loco routing, scoring. | C++17 STL, modern OWL-independent code |
| **Persistence Module** | RCD parsing, serialization helpers, INI/Help integration. | C++17 STL, file streams |
| **Diagnostics Module** | Logging, tracing, replay captures, metrics. | Pluggable sinks, configurable verbosity |
### 5.2 Layering
- **Presentation Layer**: `TMainWindow`, `TLayoutView`, dialogs. Depends only on UI Adapter interfaces.
- **Application Layer (Adapter)**: `RailController` facade holds `std::shared_ptr<RailCore::IRailEngine>`; wires callbacks to UI.
- **Domain Layer**: `RailCore` exposes `IRailEngine`, `ILayoutRepository`, `IScheduleService`, returning immutable snapshots or change events.
- **Infrastructure Layer**: File I/O (RCD, INI), logging, configuration.
### 5.3 Interface Contracts
```cpp
namespace RailCore {
  enum class StatusCode { Ok, InvalidCommand, LayoutError, InternalError };
  struct Status {
    StatusCode code;
    std::string message;   // empty on success
  };
  struct LayoutDescriptor {
    std::filesystem::path sourcePath;
    std::string name;      // shown in UI
    std::string id;        // stable identifier for regression baselines
  };
  enum class CommandId {
    Pause,
    Resume,
    Stop,
    SetDelayMode,
    AssignLoco,
    ReleaseLoco,
    TriggerHelp
    // extend as new UI actions appear
  };
  struct CommandPayload {
    CommandId id;
    std::variant<std::monostate,
                 DelaySettings,
                 LocoAssignment,
                 HelpTopic> data;
  };
  struct LayoutSnapshot {
    WorldStatePtr state;                // immutable snapshot of core entities (never null)
    SimulationClock snapshotClock;      // simulation time at capture
    std::chrono::system_clock::time_point capturedAt;
  };
  struct SimulationTickResult {
    WorldStatePtr delta;                // optional partial state diff since previous tick (nullptr if no change)
    std::vector<DomainEvent> events;    // semantic events for UI/logging
    SimulationClock clock;              // resulting simulation clock
    std::chrono::milliseconds wallTime; // real elapsed time passed to Advance
  };
  class IObserver {
  public:
    virtual void OnSnapshot(const LayoutSnapshot& snapshot) = 0;
    virtual void OnEvents(const SimulationTickResult& tick) = 0;
    virtual void OnDiagnostics(const DiagnosticsEvent& diag) = 0;
    virtual ~IObserver() = default;
  };
  class IRailEngine {
  public:
    virtual Status LoadLayout(const LayoutDescriptor& layout) = 0;
    virtual SimulationTickResult Advance(std::chrono::milliseconds dt) = 0;
    virtual Status Command(const CommandPayload& cmd) = 0; // pause, setDelay, assignLoco, etc.
    virtual LayoutSnapshot GetSnapshot() const = 0;
    virtual void Subscribe(IObserver&) = 0;
    virtual void Unsubscribe(IObserver&) = 0;
    virtual ~IRailEngine() = default;
  };
}
class IRailController {
public:
  using IRailEnginePtr = std::shared_ptr<RailCore::IRailEngine>;
  class IRailControllerDelegate {
  public:
    virtual void OnSnapshot(const RailCore::LayoutSnapshot& snapshot) = 0;
    virtual void OnTick(const RailCore::SimulationTickResult& tick) = 0;
    virtual void OnStatus(const RailCore::Status& status) = 0;
    virtual ~IRailControllerDelegate() = default;
  };
  virtual void Initialize(HWND hwndMain,
                          IRailEnginePtr engine,
                          std::shared_ptr<IRailControllerDelegate> delegate) = 0;
  virtual Status OnMenuCommand(uint32_t commandId) = 0;
  virtual Status OnTimer(uint32_t timerId, std::chrono::milliseconds elapsed) = 0;
  virtual Status OnLayoutSelection(const std::string& path) = 0;
  virtual Status OnShutdown() = 0;
};
```
#### 5.3.1 Data Type Notes
- `DelaySettings`, `LocoAssignment`, and `HelpTopic` are POD structs defined in `railcore/commands.h`, isolating UI-specific data shapes from the backend core. Each captures only serializable data so commands can be replayed in automation runs.
- `DiagnosticsEvent` encapsulates log-level, message text, and optional structured payload, giving the backend a single channel for telemetry that can be routed to the debugger, file logs, or automation transcripts.
- `IRailControllerDelegate` declares callbacks (`OnStatus`, `OnSnapshot`, `OnTick`) that fan updates into specific UI widgets; separating this from `IRailEngine::IObserver` lets the controller perform view-model transformations before reaching OWL controls and centralizes UI-side error handling.
- `DomainEvent` instances provide semantic notifications (train arrivals, loco assignments, delay state changes) with structured payloads, allowing the UI and telemetry pipeline to react without introspecting raw world-state diffs.
- `SimulationTickResult` encapsulates both the delta and resulting clock so that callers can choose between incremental UI updates (processing events) and full refreshes (consuming the provided world-state delta) without re-querying the engine.
- `WorldStatePtr` (shared pointer to immutable state) avoids large copies when publishing snapshots; observers must treat the pointed-to data as read-only and avoid retaining it beyond needed scope to limit memory growth.
#### 5.3.2 Supporting Struct Definitions (Draft)
```cpp
namespace RailCore {
  struct DelaySettings {
    DelayMode mode;                  // e.g. None, Randomized, MaintenanceOnly
    std::chrono::minutes threshold;  // used for Only-Late scenarios
    bool maintenanceThrough;         // mirrors legacy toggle
  };
  struct LocoAssignment {
    uint32_t timetableId;
    uint32_t locoId;
    AssignmentAction action;         // Assign, Release, Refuel, etc.
  };
  struct HelpTopic {
    std::string topicId;             // Allows mapping to WinHelp/HTML help IDs
  };
  struct DiagnosticsEvent {
    DiagnosticsLevel level;          // Trace, Info, Warning, Error
    std::string message;
    std::optional<StructuredPayload> payload; // structured data for automation
    std::chrono::system_clock::time_point timestamp;
  };
  struct WorldState {
    std::vector<Section> sections;
    std::vector<Route> routes;
    std::vector<Loco> locos;
    std::vector<TimetableEntry> timetable;
    SimulationClock clock;
    DelaySettings currentDelay;
    bool simulationActive;
    uint32_t tickId;                   // monotonically increasing counter
  };
  struct DomainEvent {
    DomainEventId id;                 // e.g. TrainArrived, LocoAssigned
    StructuredPayload payload;        // contextual data for UI and logs
  };
  using WorldStatePtr = std::shared_ptr<const WorldState>;
}
```
`StructuredPayload` is a thin alias for `std::variant<std::monostate, std::map<std::string, std::string>, nlohmann::json>` to keep diagnostics serialization-agnostic while supporting structured automation assertions. `DelayMode`, `AssignmentAction`, `DiagnosticsLevel`, `DomainEventId`, `Section`, `Route`, `Loco`, `TimetableEntry`, and `SimulationClock` are enums/structs defined in `railcore/types.h` to centralize domain data definitions. These structs underpin the backend library and will be refined during the implementation phase; documenting them up front keeps UI/backend contracts explicit before code changes begin.
#### 5.3.3 Service Interfaces
To remove direct file-system and OS dependencies from the backend, the engine is constructed with explicit service interfaces:
- `ILayoutRepository` resolves `LayoutDescriptor` instances to parsed layout models (`WorldState` plus metadata). The default implementation accesses on-disk `.RCD` files; tests inject in-memory repositories.
- `ITelemetrySink` consumes `DiagnosticsEvent` and `DomainEvent` streams for logging, analytics, and automation assertions.
- `IRandomProvider` supplies deterministic random numbers for simulation steps, replacing the legacy `std::rand` usage.
- `IClockService` abstracts real-time vs. simulated-time progression, enabling deterministic replay during tests.
- `IPersistenceService` provides save/export hooks for future features (e.g., scenario export) while keeping the engine unaware of file formats.
> Note: If `IPersistenceService` is `nullptr`, persistence-related commands return `StatusCode::InvalidCommand`, allowing the UI to hide or disable corresponding affordances.
`RailCore::CreateEngine(const EngineConfig& config,
                        std::shared_ptr<ILayoutRepository>,
                        std::shared_ptr<ITelemetrySink>,
                        std::shared_ptr<IRandomProvider>,
                        std::shared_ptr<IClockService>,
                        std::shared_ptr<IPersistenceService>)`
produces an `IRailEngine` wired with the supplied services. UI code typically passes default implementations, while unit tests and automation can inject fakes/mocks.
#### 5.3.4 Engine Configuration
`EngineConfig` consolidates tunable parameters so both production and test harnesses can consistently configure the engine:
```cpp
struct EngineConfig {
  std::chrono::milliseconds tickInterval {100}; // default simulation step
  bool autoPauseOnError {true};                 // pause when Command/Advance fails
  size_t maxActiveTrains {512};                // bounds for allocations
  std::filesystem::path telemetryDirectory;    // optional file sink location
  bool enableDeterministicSeeds {false};       // force fixed RNG seeds
  bool enablePersistence {false};              // allow save/export commands
};
```
- Defaults match legacy behavior (100 ms ticks, auto-pause enabled).
- `enableDeterministicSeeds` is flipped on during automated testing to ensure repeatable runs.
- `maxActiveTrains` bounds pre-allocated pools/tables; exceeding the value returns `StatusCode::InternalError` and emits diagnostics so limits can be tuned.
- `telemetryDirectory` is empty by default; when set, `ITelemetrySink` writes structured logs for diagnostics.
- Feature flags (`enablePersistence`) guard future enhancements without exposing partially implemented commands to the UI.
### 5.4 Data Flow
1. UI invokes `RailController::OnLayoutSelection`, which validates the selection, loads metadata, and calls `IRailEngine::LoadLayout`. The returned `Status` is surfaced via the delegate for UI messaging.
2. Backend requests layout data from `ILayoutRepository`, updates internal state, and emits a snapshot to registered observers.
3. Controller receives the snapshot, performs any view-model shaping (sorting, formatting), and delegates updates to bound UI widgets (`ArrivalsView`, `DeparturesView`).
4. Timers (`WM_TIMER`) call `RailController::OnTimer` with the computed elapsed duration; the controller advances the simulation, consumes resulting `DomainEvent` collections, and schedules repaint/invalidations as required (if `delta` is null, the controller skips heavy refresh work).
5. User actions (menus/toolbar) dispatch typed commands; backend returns status codes for UI feedback while also emitting telemetry and domain events through observers.
6. Application shutdown flows through `OnShutdown`, allowing UI to detach observers and persist state before tearing down the engine.
### 5.5 Concurrency Model
- Single-threaded message pump remains intact. Backend operations execute synchronously on UI thread for now.
- Future-ready: backend APIs designed to allow task runners; events carry full context to support async migration later.
### 5.6 Error Handling and Observability
- All public backend/controller entry points return `Status`, enabling consistent bubbling of validation or runtime failures up to the UI. UI code maps non-OK statuses to modal dialogs, status bar text, or telemetry without needing to inspect exceptions.
- `DiagnosticsModule` registers as an `IRailEngine::IObserver` and streams structured diagnostics. By default it writes to the debugger output (`OutputDebugString`) and optional rotating log files. CI runs can route diagnostics to JSON for archival.
- Introduce guard rails in controller methods: they log unexpected statuses, rate-limit repeated errors, and surface actionable messages (`"Layout FAST.RCD failed validation: missing selector 17"`).
- For automation, expose a `TestDiagnosticsSink` that collects events and assertions to verify no warnings/errors occurred during scripted scenarios.
### 5.7 Lifecycle & Ownership
- **Creation**: `RailUI.exe` constructs a `std::unique_ptr<RailController>` and obtains a backend instance via `RailCore::CreateEngine()` returning `std::shared_ptr<IRailEngine>`. Diagnostics and tooling share this pointer, ensuring the backend stays alive while observers remain registered.
- **Initialization**: `RailController::Initialize` wires UI delegates, registers observers, primes default state, and validates configuration. Failures return a `Status` and the caller must abort showing the main window.
- **Runtime**: UI dispatches menu/timer events; controller forwards them to the backend and pushes resulting snapshots to delegates. If `Advance` returns a non-OK status the controller pauses timers and surfaces the issue through both the delegate and diagnostics sink.
- **Shutdown**: `OnShutdown` unsubscribes observers, flushes pending diagnostics, persists controller-managed state (e.g., last layout path), and releases references to backend services before the window is destroyed.
- **Thread Safety**: Backend mutating APIs execute on the UI thread, while read-only snapshot accessors are const and internally synchronized. This design allows future background analytics or scripting hosts without rewriting the engine.
## 6. Build & Deployment
- Solution structure (MSVC + CMake):
  - `RailCore` static library built with `/std:c++17`, `/permissive-`, `/Zc:__cplusplus`, and `/W4`. Public headers reside in `include/railcore/`.
  - `RailUI` executable linking OWLNext (via `find_package(owlnext CONFIG)`), `RailCore`, and the UI adapter layer.
  - `RailCoreTests` GoogleTest target consuming `RailCore` plus fakes for persistence and timing services.
  - `RailUIChecks` optional automation harness (pywinauto/WinAppDriver) triggered via CTest custom commands.
- Provide CMake presets (`msvc-debug`, `msvc-release`) and a `Directory.Build.props` for Visual Studio integration.
- Introduce `RailCoreConfig.cmake` to allow downstream tools (e.g., property tests, simulation drivers) to link the backend without duplicating configuration.
- Publish NuGet-style package for OWLNext binaries or include `third_party/owlnext` as a CMake subproject to keep onboarding reproducible.
- Ship a `railcore/default_services` library that wires production implementations for all injected services, so UI/bootstrapper code stays thin.
- Vendor `nlohmann::json` (header-only) via CPM or a `third_party` submodule for diagnostics payload support.
- Deployment artifacts remain `railc.exe`, `railcore.pdb`, resource files, and help assets; packaging scripts now gather binaries from the MSVC build tree rather than Borland output.
## 7. Testing Strategy Alignment
- GoogleTest suites cover `IRailEngine` behaviors, RCD parsing, timetable logic.
- Property-based tests (rapidcheck) operate on backend data models without OWL dependencies.
- UI automation (pywinauto/WinAppDriver) validates controller-to-UI binding and rendering updates.
- Coverage tooling runs separately for `railcore` (unit) and `RailUI.exe` (automation) builds.
## 8. Migration Plan
1. **Preparation**  
   - Introduce `RailCore` namespace, define POD models (`Section`, `Route`, `Loco`, `TimetableEntry`).  
   - Add skeleton `IRailEngine` and `RailController`.
   - Define service abstractions (`ILayoutRepository`, `ITelemetrySink`, `IRandomProvider`, `IClockService`, `IPersistenceService`) and stub implementations housed under `railcore/services.h`.
2. **Data Extraction**  
   - Move parsing logic from `LAYOUT.CPP` to `railcore/layout_loader.cpp`; return pure models.  
   - Replace global arrays with `RailCore::WorldState` container managed by the engine.
3. **Simulation Refactor**  
   - Port timing, delay, and routing functions into backend classes.  
   - Introduce deterministic random provider injected via interface.
4. **UI Integration**  
   - Update `TMainWindow`/`TLayout` to hold `std::unique_ptr<RailController>`; handlers forward to controller methods and UI widgets subscribe via delegate adapters (`ArrivalsViewAdapter`, `StatusBarAdapter`).  
   - Replace direct global mutations with controller calls and remove helper functions that expose raw pointers to global arrays.
5. **Validation**  
   - Run regression suite (manual + automated) comparing legacy Borland build outputs with new backend for key layouts.  
   - Enable backend unit tests in CI.
6. **Cleanup**  
   - Decommission unused globals, update documentation, and archive Borland-specific code paths.
## 9. Risks & Mitigations
- **Large refactor surface** - Mitigate with feature flags and incremental commits gated by tests.  
- **Behavioral drift** - Capture golden snapshots (arrival/departure timelines, scoring) and assert equality in backend tests.  
- **UI coupling surprises** - Implement controller adapter layer with minimal initial API to avoid rewiring entire UI at once.  
- **Performance regressions** - Profile backend operations when extracted; ensure memory allocations remain bounded.
- **Snapshot retention** - Enforce observer contracts to release `WorldStatePtr` promptly and add diagnostics that flag when outstanding snapshots exceed configured thresholds.
- **Service misconfiguration** - Centralize engine construction through a factory and add startup diagnostics that verify all injected services are non-null and configured.
## 10. Open Questions
- Do we maintain WinHelp integration or migrate to HTML-based help simultaneously?  
- Should backend expose scripting hooks (Lua/Python) for future extensibility?  
- What is the long-term plan for audio/Multimedia API usage currently invoked from UI code?
## 11. Success Metrics
- Backend unit test coverage >= 70% line coverage on core scheduling modules and >= 80% function coverage on `Advance`, layout parsing, and command handlers.  
- UI regression suite runs unattended and completes within 10 minutes.  
- Removal of direct global array access from `TLayout`/`TMainWindow` (verified by static analysis).  
- Ability to spin up a console-based simulation driver linking only `railcore` without OWL dependencies.  
- Snapshot backlog stays below configured threshold during automation (monitored via telemetry from `ITelemetrySink`).
- Nightly automation reports no `StatusCode::InternalError` occurrences; diagnostics log counts remain at or below defined SLAs.
