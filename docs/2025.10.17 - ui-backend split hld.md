# Rail Control UI/Backend Split - High-Level Design

## 1. Purpose
- Establish a clear architectural boundary between the presentation layer (OWLNext UI) and core simulation logic so that the modernization effort can leverage MSVC/OWLNext while enabling automated testing and future UI evolutions.
- Preserve existing functionality and data artifacts (RCD layouts, WinHelp content) while improving maintainability, testability, and portability.

## 2. Scope
- Applies to new MSVC/OWLNext 7.x build; legacy Borland build remains only as a validation reference.
- Covers runtime components inside the executable, public/internal interfaces, and supporting build/test infrastructure.
- Excludes front-end visual redesign, data format changes, or deployment packaging.

## 3. Current State (17 Oct 2025)
- `TMainWindow` and `TLayout` own both rendering and business logic; global arrays (`PSectionInfo`, `PTimetableInfo`, etc.) are mutated directly from OWL event handlers.
- Timers, randomization, and file I/O are interwoven with UI classes, preventing headless execution.
- No cohesive module exposes the simulation state, making automated testing and alternative front ends difficult.

## 4. Design Goals
1. **Separation of Concerns** - UI handles input, rendering, and user affordances; backend handles simulation state, scheduling, and persistence.
2. **Testability** - Backend compiles into a static library (`railcore.lib`) with deterministic APIs suitable for GoogleTest/property tests.
3. **Determinism & Observability** - Backend surfaces explicit update ticks, logging hooks, and query APIs; UI subscribes via observers.
4. **Incremental Migration** - Enable phased refactors while maintaining a bootable application.

## 5. Proposed Architecture

### 5.1 Component Overview
| Component | Responsibility | Key Technologies |
| --- | --- | --- |
| **RailUI.exe** | Hosts OWLNext windows, menu handlers, dialogs, rendering surfaces, automation hooks. | OWLNext 7.x, Win32 GDI |
| **UI Adapter Layer** | Translates UI events into backend requests, marshals updates back to UI/stateful widgets. | C++17 interfaces, observer pattern |
| **RailCore (static lib)** | Deterministic simulation engine: layout parsing, timetable execution, loco routing, scoring. | C++17 STL, modern OWL-independent code |
| **Persistence Module** | RCD parsing, serialization helpers, INI/Help integration. | C++17 STL, file streams |
| **Diagnostics Module** | Logging, tracing, replay captures, metrics. | Pluggable sinks, configurable verbosity |

### 5.2 Layering
- **Presentation Layer**: `TMainWindow`, `TLayoutView`, dialogs. Depends only on UI Adapter interfaces.
- **Application Layer (Adapter)**: `RailController` facade holds `std::shared_ptr<RailCore::IRailEngine>`; wires callbacks to UI.
- **Domain Layer**: `RailCore` exposes `IRailEngine`, `ILayoutRepository`, `IScheduleService`, returning immutable snapshots or change events.
- **Infrastructure Layer**: File I/O (RCD, INI), logging, configuration.

### 5.3 Interface Contracts
```cpp
namespace RailCore {
  struct LayoutSnapshot { /* sections, routes, selectors, locos */ };
  struct SimulationTickResult { /* time, events, deltas */ };

  class IRailEngine {
  public:
    virtual void LoadLayout(const LayoutDescriptor& layout) = 0;
    virtual SimulationTickResult Advance(std::chrono::milliseconds dt) = 0;
    virtual void Command(const Command& cmd) = 0; // pause, setDelay, assignLoco, etc.
    virtual LayoutSnapshot GetSnapshot() const = 0;
    virtual void Subscribe(IObserver&) = 0;
    virtual ~IRailEngine() = default;
  };
}

class IRailController {
public:
  virtual void Initialize(HWND hwndMain, IRailEnginePtr engine) = 0;
  virtual void OnMenuCommand(uint32_t commandId) = 0;
  virtual void OnTimer(uint32_t timerId) = 0;
  virtual void OnLayoutSelection(const std::string& path) = 0;
};
```

### 5.4 Data Flow
1. UI invokes `RailController::OnLayoutSelection`, which requests `RailEngine.LoadLayout`.
2. Backend parses RCD via `LayoutRepository`, updates internal state, and emits a snapshot.
3. Controller receives event, updates bound UI widgets (`ArrivalsView`, `DeparturesView`) via observer callbacks.
4. Timers (`WM_TIMER`) call `RailController::OnTimer`, which advances the simulation; backend emits changes that the controller pushes to the UI.
5. User actions (menus/toolbar) dispatch commands to backend; backend returns status codes for UI feedback.

### 5.5 Concurrency Model
- Single-threaded message pump remains intact. Backend operations execute synchronously on UI thread for now.
- Future-ready: backend APIs designed to allow task runners; events carry full context to support async migration later.

## 6. Build & Deployment
- Create `railcore` static library project (MSVC + CMake) built with `/std:c++17`.
- Main application links against `railcore` plus UI adapter sources.
- Unit tests target `railcore`; integration/UI automation target `RailUI.exe`.
- Introduce `RailCoreConfig.cmake` for external tooling reuse (e.g., property tests).

## 7. Testing Strategy Alignment
- GoogleTest suites cover `IRailEngine` behaviors, RCD parsing, timetable logic.
- Property-based tests (rapidcheck) operate on backend data models without OWL dependencies.
- UI automation (pywinauto/WinAppDriver) validates controller-to-UI binding and rendering updates.
- Coverage tooling runs separately for `railcore` (unit) and `RailUI.exe` (automation) builds.

## 8. Migration Plan
1. **Preparation**  
   - Introduce `RailCore` namespace, define POD models (`Section`, `Route`, `Loco`, `TimetableEntry`).  
   - Add skeleton `IRailEngine` and `RailController`.
2. **Data Extraction**  
   - Move parsing logic from `LAYOUT.CPP` to `railcore/layout_loader.cpp`; return pure models.  
   - Replace global arrays with `RailCore::WorldState` container managed by the engine.
3. **Simulation Refactor**  
   - Port timing, delay, and routing functions into backend classes.  
   - Introduce deterministic random provider injected via interface.
4. **UI Integration**  
   - Update `TMainWindow`/`TLayout` to hold `std::unique_ptr<RailController>`; handlers forward to controller.  
   - Replace direct global mutations with controller calls.
5. **Validation**  
   - Run regression suite (manual + automated) comparing legacy Borland build outputs with new backend for key layouts.  
   - Enable backend unit tests in CI.
6. **Cleanup**  
   - Decommission unused globals, update documentation, and archive Borland-specific code paths.

## 9. Risks & Mitigations
- **Large refactor surface** - Mitigate with feature flags and incremental commits gated by tests.  
- **Behavioral drift** - Capture golden snapshots (arrival/departure timelines, scoring) and assert equality in backend tests.  
- **UI coupling surprises** - Implement controller adapter layer with minimal initial API to avoid rewiring entire UI at once.  
- **Performance regressions** - Profile backend operations when extracted; ensure memory allocations remain bounded.

## 10. Open Questions
- Do we maintain WinHelp integration or migrate to HTML-based help simultaneously?  
- Should backend expose scripting hooks (Lua/Python) for future extensibility?  
- What is the long-term plan for audio/Multimedia API usage currently invoked from UI code?

## 11. Success Metrics
- Backend unit test coverage >= 70% on core scheduling modules.  
- UI regression suite runs unattended and completes within 10 minutes.  
- Removal of direct global array access from `TLayout`/`TMainWindow` (verified by static analysis).  
- Ability to spin up a console-based simulation driver linking only `railcore` without OWL dependencies.
