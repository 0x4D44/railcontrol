# Automated Testing Strategy for Rail Control

## Context Snapshot
- Modernization in-flight: new primary toolchain is MSVC (Visual Studio 2022 or newer) targeting 32-bit Windows with the latest OWLNext (7.x) while legacy Borland assets exist for reference.
- Application entry remains `RAILC.CPP`; most domain logic resides in `LAYOUT.CPP` and friends, with extensive global state accessed from `TMainWindow`/`TLayout`.
- Existing build uses batch/make scripts; a new CMake/MSBuild pipeline will coexist to support automated tests and CI.
- Sample `.RCD` layouts, WinHelp assets, and resources continue to drive realistic scenarios and should be leveraged by automated suites.

## Testing Goals
1. Exercise timetable, routing, and locomotive state transitions without spinning up the full GUI.
2. Smoke the UI to catch regressions in menu actions, dialogs, and drawing.
3. Track measurable coverage so refactors are informed by data even if the shipping binary is still produced with Borland.

## Candidate Frameworks

### C++ Unit Testing (non-GUI logic)
| Framework | Pros | Considerations |
| --- | --- | --- |
| **GoogleTest** | Rich assertions, death tests, mocks, integrates with `ctest`/CI, supported first-class by MSVC. | Preferred default; pair with CMake presets and Visual Studio Test Explorer for developer ergonomics. |
| **Catch2** | Single-header, minimal boilerplate, expressive BDD-style sections. | Lightweight alternative if keeping dependencies small is critical. |
| **doctest** | Header-only, extremely fast compile times, easy to embed near implementation files. | Useful for component-level tests co-located with sources; lacks some advanced matchers. |

Recommendation: treat the MSVC/OWLNext build as authoritative, compiling non-UI logic (timetable parsing, routing, status state machines) into a `railcore` static library and linking it into GoogleTest-based suites. Retain legacy Borland artifacts only until the migration is complete.

### Property / Scenario Testing
- **rapidcheck** (C++ QuickCheck) can stress timetable/route combinatorics once data access is decoupled from global arrays.
- **ApprovalTests.cpp** suits verifying rendered textual outputs (e.g., debug dumps of layouts) where pixel-perfect GUI comparison is impractical.

### UI / High-Level Automation
| Tool | Pros | Considerations |
| --- | --- | --- |
| **WinAppDriver + Appium** | Official Windows UI Automation, language-agnostic clients (C#, Python, JS). | Requires instrumenting control names via Win32 accessibility; legacy OWL controls may need `CreateAutomationId` helpers or wrapper windows. |
| **pywinauto** (Python) | Quick scripting over Win32 handles, good for menu/dialog regression tests. | Purely procedural; assertions live in Python. Works well for nightly smoke runs. |
| **AutoHotkey** | Simple keystroke/mouse playback. | Best for minimal smoke scripts; weaker assertions and maintenance story. |
| **WinVerifyUIA / TestStack.White (C#)** | Stronger typing and UIA abstractions. | Needs .NET harness project; consider if team is comfortable in C#. |

For drawing validation, pair automation with bitmap diffing (e.g., `Pillow` + perceptual hash) on key windows after ensuring deterministic seeds (`srand`) to avoid random noise.

### Legacy-Friendly Options
- For any residual Borland-only surfaces that persist during migration, **CppUnit** or **Boost.Test** may serve as temporary harnesses, but invest in shrinking this footprint quickly to avoid double maintenance.

## Bringing Existing Code Under Test
1. **Carve out domain seams**  
   - Extract timetable parsing/loading from `TLayout::LoadFile` into a pure function returning structs (new `layout_loader.cpp`).  
   - Encapsulate status transitions (`CalcArrivalTime`, `CodeCalculate`, loco assignment) behind interfaces that take POD inputs instead of referencing globals directly.
2. **Create a headless library**  
   - Add a `railcore` static library project that builds a subset of files without OWL includes. Use lightweight adapter classes to supply the data the UI currently stores on globals.
3. **Design fixtures**  
   - Use the sample `.RCD` files as golden inputs. Write fixtures that load them from disk, then assert on parsed section counts, timetable ordering, and delay calculations.  
   - Expose deterministic random seeds (`srand(0)`) to keep simulations repeatable.
4. **Integration hooks**  
   - Add a message-pump aware harness (`tests/integration/SimulationDriver.cpp`) that spins `TApplication` with a fake window class, drives menu commands, and inspects state via exported functions. Compile this harness under MSVC so it exercises the modern OWLNext surface; keep adapters for any legacy-only flows until retired.
5. **UI smoke scripts**  
   - Define automation scenarios: launch app, open each sample layout, toggle Arrivals/Departures windows, invoke configuration dialog, request help. Store scripts under `tests/ui/` and run via `python -m pytest` (if using pywinauto) so failures produce tracebacks and screenshots.

## UI vs Backend Separation
- **Current state (17 Oct 2025):** `TLayout` and `TMainWindow` interleave rendering, user input, and business rules. The core state (sections, routes, locos, timetable arrays) lives as globals managed directly by these window classes. Domain mutations are triggered in response handlers scattered across UI code (`CMMnuFiSetD`, `CMWinArriva`, etc.), which in turn reach into globally accessible arrays. There is no standalone backend module that can run without a window handle.
- **Gap to target:** To enable modern testing, a backend should expose deterministic services (layout loading, timetable simulation, routing decisions) free of Windows/OWL dependencies. Today, these responsibilities sit inside OWL classes and depend on `owl::TWindow`, timers, and direct GDI handles. We are therefore at ~0% separation—the backend conceptually exists but is inseparable from the UI layer.
- **Refactor objectives:**  
  1. Define plain-old-data models for sections, selectors, routes, locos, and timetables.  
  2. Move parsing, scheduling, and status-transition logic into a `railcore` namespace that accepts/returns those models and exposes explicit lifecycle APIs (e.g., `AdvanceSimulationStep`, `AssignLoco`).  
  3. Let the OWL UI become a thin presenter translating UI events into backend calls and subscribing to backend change notifications (observer pattern).  
  4. Retire global arrays in favor of backend-owned containers passed to the UI through interfaces.
- **Short-term milestones:**  
  - Extract timetable parsing first, followed by loco scheduling routines.  
  - Introduce a façade class (`RailController`) that wraps backend calls; update UI handlers to call the façade instead of manipulating globals directly.  
  - Provide serialization hooks so both tests and UI can hydrate equivalent state.
- **Testing impact:** Once the backend stands alone, the majority of unit and property tests can exercise it without spinning up OWL windows, dramatically improving automation fidelity. UI automation can then focus purely on verifying the presentation layer.

## Coverage Strategy
1. **Unit/Domain Tests**  
   - Enable `/PROFILE`, `/Qspectre`, and `/DEBUG:FULL` in MSVC test builds to emit coverage-friendly PDBs. Use `OpenCppCoverage`, `Visual Studio Code Coverage`, or `llvm-cov` (via Clang-cl) to publish HTML reports filtered to project directories.  
   - For cross-checking on Clang/LLD builds, rely on `llvm-profdata` + `llvm-cov`.
2. **UI/Integration Scripts**  
   - Wrap the modern MSVC-built executable in `OpenCppCoverage` to capture edges exercised by automation. Ensure symbol paths resolve to PDBs emitted during the MSVC build so coverage maps cleanly to source.
3. **Baseline Metrics**  
   - Track separate coverage baselines: `core` (headless library) and `ui` (automation). Document thresholds in CI to avoid conflating them.
4. **Reporting**  
   - Publish coverage artifacts to a `docs/coverage/` folder or CI artifact store. Link to them from PR templates to enforce visibility.

## Incremental Adoption Plan
1. Stand up a modern toolchain build (CMake preset or `build_msvc.bat`) that compiles a subset of sources and links GoogleTest; get a first test running against `CodeCalculate`.  
2. Evaluate UI automation feasibility with a thin pywinauto script that launches `railc.exe`, opens `FAST.RCD`, and validates the title bar text.  
3. Extract timetable parsing into a standalone unit, cover it with doctest/GoogleTest cases using recorded `.RCD` fixtures.  
4. Expand unit coverage to loco scheduling and delay calculations; introduce property-based checks for status transitions.  
5. Add OpenCppCoverage (or Visual Studio coverage tooling) to the CI workflow to produce reports for both unit and UI layers targeting the modern binary.  
6. Iterate on refactors that reduce global state, making additional subsystems testable (selectors, routes, audio).  
7. Sunset Borland-specific builds once parity tests pass; gate releases on the automated suite running against the MSVC/OWLNext executable.

## Open Questions & Risks
- Borland toolchain compatibility with instrumentation is limited; dual-toolchain maintenance must not drift.  
- OWL windows may lack automation-friendly names; we might need to subclass or provide helper functions to expose identifiers.  
- Determinism: random seeds and timer-driven state updates must be controllable to avoid flakey tests.  
- Long-term goal could include migrating UI to a testable framework (e.g., OWLNext on MSVC fully) to reduce reliance on emulation layers.

## Immediate Next Steps
1. Prototype MSVC build of `LAYOUT.CPP` + dependencies as a static library and confirm GoogleTest links cleanly.  
2. Author the first pywinauto smoke test targeting menu navigation.  
3. Investigate symbol generation from Borland objects to understand whether OpenCppCoverage can ingest them or if a parallel MSVC binary is mandatory.
