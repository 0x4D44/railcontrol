# UI/Backend Split — Multi‑Stage Implementation Plan

This plan turns the High‑Level Design (HLD) into concrete, sequenced work packages with deliverables, acceptance criteria, risks, and validation steps. It assumes MSVC + OWLNext 7.0.19, Windows x86 (Win32), and adopts the interfaces and semantics defined in the HLD (IRailEngine, AdvanceOutcome, IObserver, ILayoutRepository, etc.).

## Stage 0 — Foundations and Build Plumbing
- Goals
  - Establish projects/targets: `RailCore` (static lib), `RailCoreTests` (GoogleTest), ensure `railc_msvc.exe` continues to build unchanged.
- Tasks
  - Create `build\msvc\RailCore.vcxproj` and `build\msvc\RailCoreTests.vcxproj`.
  - Add `include\railcore\` and `src\railcore\` folders; wire headers/sources.
  - Vendor or reference GoogleTest for MSVC. Hook into Test Explorer / `vstest.console.exe`.
  - Update `build_msvc.bat` to build RailCore and RailCoreTests after OWLNext.
  - CI: Extend `.github/workflows/msvc.yml` to build and run tests in Debug.
- Deliverables
  - Empty `railcore.lib` builds; tests project compiles and runs a placeholder test.
- Acceptance Criteria
  - `build_msvc.bat Debug` produces `railcore.lib` and runs tests successfully.
  - CI shows green job for Debug build + tests.
- Risks/Mitigations
  - Risk: gtest integration friction. Mitigate by using official NuGet or submodule.

## Stage 1 — Contracts and Core Types (No Behavior)
- Goals
  - Define stable interfaces and PODs from HLD to unblock downstream work.
- Tasks
  - Add headers: `railcore/status.h`, `railcore/types.h`, `railcore/commands.h`, `railcore/observer.h`, `railcore/engine.h`, `railcore/services.h`.
  - Declare: `StatusCode` (Ok, InvalidCommand, LayoutError, ValidationError, NotFound, Busy, InternalError), `Status`, core domain PODs, `DomainEvent`, `StructuredPayload` (variant<monostate, map<string,string>>), `WorldState`, `WorldDelta`, `LayoutDescriptor`, `SimulationTickResult`, `AdvanceOutcome`, `IObserver`, `IRailEngine` (including `Reset()`), service interfaces.
  - Provide a no‑op `CreateEngine(...)` factory in `railcore/engine_factory.cpp` returning a stub that compiles but does nothing.
- Deliverables
  - Compiling headers with unit tests that assert type presence and basic invariants (e.g., enums, default values).
- Acceptance Criteria
  - Contracts compile in isolation (no OWL/Win32 includes).
  - Unit tests for trivial behaviors (default constructability, enum ranges) pass.
- Risks/Mitigations
  - Over‑specification; keep initial types minimal and grow with needs.

## Stage 2 — Layout Repository + Validation Pipeline (Parse Only)
- Goals
  - Headless parsing of `.RCD` into normalized models with validation, but no simulation.
- Tasks
  - Implement `ILayoutRepository` default: `RcdLayoutRepository` in `src/railcore/persistence/`.
  - Add layered validation from HLD 5.3.8: parse/normalize → structural checks → cross‑reference resolution → derive metadata → compute `LayoutDescriptor.id` (SHA‑256 over canonicalized bytes + schema).
  - Add diagnostics events for validation failures with concise `Status.message`.
  - Tests: fixture‑based parsing for `FAST.RCD`, `KINGSX.RCD`, `QUEENST.RCD`, `WAVERLY.RCD` (counts, name uniqueness, reference integrity).
- Deliverables
  - `RcdLayoutRepository` with deterministic IDs; tests covering expected counts/order.
- Acceptance Criteria
  - `LoadLayout` through a thin engine stub returns `Status::Ok` and a snapshot with `WorldState` populated (no timers/logic).
  - Invalid/mutated RCD samples yield `ValidationError`/`LayoutError` with diagnostics.
- Risks/Mitigations
  - Legacy quirks in `.RCD`; add tolerant normalization to avoid false negatives.

## Stage 3 — Engine Skeleton and Deterministic Clock/RNG
- Goals
  - Implement `IRailEngine` life‑cycle and tick plumbing without domain transitions.
- Tasks
  - Engine state machine: Idle → Loaded (Paused) → Running; implement `Pause/Resume/Stop/Reset` semantics and idempotence.
  - Wire `IClockService` (simulated time for tests) and `IRandomProvider` (seeded by `EngineConfig::enableDeterministicSeeds`).
  - Implement `Advance(std::chrono::milliseconds dt)` returning `AdvanceOutcome` with valid clock progression; emit empty `DomainEvent` sets.
  - Observer wiring: `OnSnapshot` exactly once on successful load; `OnEvents` on each successful tick; no emissions on errors or `Reset`.
  - Tests: state transitions, idempotence, re‑entrancy returns `Busy`, clock clamping and diagnostics on oversized `dt`.
- Deliverables
  - Engine that loads layouts (from Stage 2), advances time deterministically, and notifies observers.
- Acceptance Criteria
  - Unit tests cover transitions and observer/event ordering rules; deterministic ticks verified.
- Risks/Mitigations
  - Event ordering edge cases; encode rules in tests (HLD 5.4.1).

## Stage 4 — Command Handling: Delay + Loco Assignment (Validation Only)
- Goals
  - Accept and validate `SetDelayMode` and `AssignLoco` without altering world yet.
- Tasks
  - Validate `DelaySettings` bounds from `EngineConfig`; status: `ValidationError` on invalid inputs.
  - Validate `AssignLoco` references (`NotFound` on bad IDs) and preconditions (engine state not `Idle`/`Stopped`).
  - Emit `DomainEvent` entries for accepted commands (even if no state change yet) to support automation scripts.
  - Tests: positive/negative cases, idempotence text (`Ok, no‑op`) for redundant `Pause/Resume`.
- Deliverables
  - Command validation path with diagnostics; event stubs emitted.
- Acceptance Criteria
  - Command tests pass; controller can call into engine without mutation.
- Risks/Mitigations
  - Early coupling; keep mutation stubs minimal until Stage 5.

## Stage 5 — Core State Transitions (Scheduling, Routing, Delays)
- Goals
  - Move business logic from legacy globals to backend: basic scheduling, arrival/departure time updates, and loco/section occupancy rules.
- Tasks
  - Extract pure functions from `LAYOUT.CPP`/related files into `src/railcore/domain/` (e.g., timetable step evaluation, delay application, section allocation checks).
  - Integrate into engine `Advance`: compute transitions for the current tick based on world + commands; update `WorldState` and `tickId` only when changes occur.
  - Produce `DomainEvent`s for significant transitions; keep `WorldDelta` = nullptr initially, then populate select hot paths (e.g., timetable entry status changes).
  - Tests: deterministic scenarios over sample layouts; assert on clocked transitions, counts, and specific events.
- Deliverables
  - Minimal but correct simulation step covering timetable progression; section/loco occupancy consistent.
- Acceptance Criteria
  - Unit tests pass for happy paths and selected edge cases; no re‑entrancy; memory stable (no long‑lived shared_ptr cycles).
- Risks/Mitigations
  - Behavioral drift vs. legacy; build golden baselines from current MSVC behavior and compare key metrics.

## Stage 6 — WorldDelta and Incremental UI Updates
- Goals
  - Implement `WorldDelta` population for common updates to reduce UI refresh cost.
- Tasks
  - Introduce `EntityDelta` generation for timetable entry state changes, loco position/assignment, and section occupancy.
  - Keep deltas optional; initial implementations can continue with `delta = nullptr` if change sets are large.
  - Tests: verify presence/absence of deltas and that deltas correspond to applied transitions.
- Deliverables
  - Useful `WorldDelta` diffs for incremental updates.
- Acceptance Criteria
  - Delta tests pass; UI can choose deltas without breaking when null.
- Risks/Mitigations
  - Over‑diffing; start with high‑value diffs and expand as needed.

## Stage 7 — Controller Adapter and UI Integration
- Goals
  - Replace direct global mutations with controller calls; subscribe UI views to engine via delegate adapters.
- Tasks
  - Add `RailController` implementing `IRailController` from HLD; route menu/timer events to engine; map statuses to UI.
  - Replace UI usages of global arrays with controller queries/snapshots.
  - Ensure `Initialize(HWND)` accepts `nullptr` for headless tests; subscribe/unsubscribe per HLD lifecycle.
  - Manual smoke tests: open each sample layout, run/pause/stop, check arrivals/departures updates, status bar messages.
- Deliverables
  - UI builds and operates through the backend; globals usage removed from primary flows.
- Acceptance Criteria
  - Manual smoke passes; no direct writes to legacy globals in main flows (grep gate).
- Risks/Mitigations
  - UI coupling surprises; stage refactors by view (Arrivals → Departures → Status Bar → Toolbar).

## Stage 8 — Coverage, Property Tests, and CI Artifacts
- Goals
  - Establish robust coverage and deeper invariants.
- Tasks
  - Integrate OpenCppCoverage or VS Enterprise Coverage for `RailCoreTests`; publish HTML artifacts.
  - Add property tests (rapidcheck) for timetable/routing invariants (e.g., no two locos occupy same section at same tick).
  - Add fuzzing harness (clang‑cl + libFuzzer) for RCD parser optionally (off by default in CI).
- Deliverables
  - Coverage reports in CI; property tests running in Debug.
- Acceptance Criteria
  - Back‑end coverage ≥ 70% lines on core modules; property tests green.
- Risks/Mitigations
  - Flakiness; enforce deterministic seeds and simulated clock.

## Stage 9 — Performance, Limits, and Diagnostics Quality
- Goals
  - Validate config bounds and performance envelopes; harden diagnostics.
- Tasks
  - Enforce `EngineConfig` bounds: `maxActiveTrains`, `maxSections`, `maxRoutes`, `maxTimetableEntries`; return `ValidationError`/`InternalError` per HLD rules.
  - Add targeted profiling on `Advance` hot paths; reduce allocations; pool event objects if necessary.
  - Improve diagnostics: rate‑limit repeated messages; ensure meaningful `Status.message` values; add file sink if `telemetryDirectory` set.
- Deliverables
  - Stable performance under typical layouts; meaningful logs for CI runs.
- Acceptance Criteria
  - No allocation spikes; no `InternalError` in nightly runs; diagnostics within rate limits.
- Risks/Mitigations
  - Hidden O(N^2) in routing; measure and micro‑opt after correctness is locked.

## Stage 10 — Cleanup and Parity Gates
- Goals
  - Remove dead globals and finalize documentation; gate on parity.
- Tasks
  - Delete or isolate legacy global mutation helpers; assert no remaining UI/global dependencies (static analysis or grep rules in CI).
  - Document public backend APIs (`/docs`), update README with headless testing usage.
  - Establish parity gates: compare selected timeline/scoring snapshots to golden MSVC baselines.
- Deliverables
  - Clean tree with backend contracts in place; docs and gates published.
- Acceptance Criteria
  - Parity suite green; UI smoke passes; CI green.
- Risks/Mitigations
  - Edge flows missed; expand parity corpus iteratively.

---

## Cross‑Cutting Guidelines
- Determinism: Use `IClockService` (simulated time) and `IRandomProvider` with fixed seeds in tests.
- Error Handling: All public methods return `Status` or `AdvanceOutcome`; controllers never infer errors from empty results.
- Observer Ordering: One snapshot on load, events on each successful tick, none on errors/reset.
- Headless Posture: All backend tests run without HWND; controller `Initialize(nullptr, ...)` is valid.

## Milestone Checkpoints
- M0 (Stage 0–1): Contracts compile; CI builds and runs placeholder tests.
- M1 (Stage 2–3): RCD parsing + engine tick; observer events fire deterministically.
- M2 (Stage 4–5): Command validation + basic scheduling transitions with tests.
- M3 (Stage 6–7): WorldDelta in hot paths; UI integrated via controller; globals gone from main flows.
- M4 (Stage 8–9): Coverage ≥ 70%; property tests; perf and limits hardened.
- GA (Stage 10): Parity gates green; documentation complete.

## Acceptance Matrix (Summary)
- Build: `railc_msvc.exe`, `railcore.lib`, `RailCoreTests` pass locally and in CI.
- Testability: Backend headless tests exercise parsing, scheduling, routing deterministically.
- Observability: Diagnostics and events sufficient for CI triage; rate‑limited.
- Maintainability: Clear module boundaries; no OWL/Win32 leakage into backend.

