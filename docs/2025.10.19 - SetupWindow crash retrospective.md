# SetupWindow Crash Retrospective

## Summary
During startup the MSVC Debug build of Rail Control reliably crashed inside `TFrameWindow::SetupWindow`. The root cause was a stack buffer overrun in `TLayout::StartNew`, which allocated an eight-element scratch array but passed it to `TTimetable`, a constructor that reads nine integers. Every new timetable read the ninth element, overwriting saved stack data and destabilizing the caller. Correcting the buffer size resolved the crash.

## Timeline
- **2025-10-17:** Added guard instrumentation (`gSetupWindowSavedEsi`, `gSetupWindowExpectedEsi`) to track corruption of the saved ESI slot in `TMainWindow::SetupWindow`.
- **2025-10-18:** Captured hardware breakpoint hits showing the slot flipping immediately after the Borland-derived base `SetupWindow` returned, but the actual culprit remained unknown.
- **2025-10-19 05:55:** Revisited the instrumentation plan and launched cdb with automated scripts.
- **2025-10-19 06:02:** Hardware watch fired inside `_EH_prolog3_GS`; this revealed the guard was monitoring the MSVC security cookie location, yielding a false positive.
- **2025-10-19 08:38:** Adjusted guard offsets to the correct stack slot and confirmed the cookie write was no longer flagged.
- **2025-10-19 08:44:** Converted the guard to self-seed; no mismatches observed, but the Game→New command still crashed.
- **2025-10-19 08:55:** Reran cdb with watchpoints and observed the crash occurring immediately after the OWL base `SetupWindow` call.
- **2025-10-19 09:00:** Audited `TLayout::StartNew` and discovered the eight-element `TempArray`; sized it to nine elements.
- **2025-10-19 09:04:** Rebuilt Debug; crash no longer reproduced, Game→New succeeded.
- **2025-10-19 09:10:** Removed guard instrumentation from both app code and OWL core now that the underlying issue was fixed.

## Debugging Approach and Tools
1. **Stack Guard Instrumentation (C++ code):** Added temporary globals/macros that captured the address and expected value of the saved ESI slot to detect when the pointer diverged. This provided breadcrumbs (`gSetupWindowGuardTag`) indicating which milestone tripped the guard.
2. **cdb (Windows Console Debugger):** Used scripted command files to automate breakpoints (`bp`), hardware watchpoints (`ba w4`), context dumps (`kv`, `r`), and to replay the guard scenario quickly. Scripts lived under `tmp/cdb_*.txt` and were invoked via `cdb.exe -cf` to guarantee repeatability.
3. **MSBuild + VS Toolchain:** Rebuilt the MSVC Debug configuration repeatedly (`msbuild ... /p:Configuration=Debug /p:Platform=x86`) to ensure instrumentation and fixes compiled cleanly.
4. **Code Audits:** After eliminating the false positive from the GS cookie, manual inspection of `TLayout::StartNew`, `TTimetable`, and related data structures revealed the off-by-one buffer (eight elements vs. nine). Correlating constructor usage with `TempArray` made the overrun evident.
5. **Iterative Guard Removal:** Once the root cause was fixed, the guard instrumentation was stripped to avoid lingering overhead and complexity, returning the codebase to its original state.

## Root Cause
`TLayout::StartNew` allocated `int TempArray[8];` but passed it to `TTimetable`, which assumes nine integers (`xiValue[0..8]`). As a result, `TTimetable` read past the end of the stack buffer and overwrote saved registers (including the saved ESI pointer) in `TMainWindow::SetupWindow`’s frame. This corruption manifested as crashes inside `_EH_prolog3_GS` and `TFrameWindow::SetupWindow` when the frame attempted to access restored stack data.

## Resolution
- Resized the scratch buffer to `int TempArray[9];` and zeroed all nine elements before use (`LAYOUT.CPP:435` and `LAYOUT.CPP:439`).
- Rebuilt the MSVC Debug target to validate the fix.
- Removed all guard-specific globals/macros and documentation references now that the investigation concluded.

## Lessons Learned
1. **Match Scratch Buffers to Consumers:** When passing temporary arrays to downstream constructors/functions, confirm the expected element count—especially when legacy code evolves.
2. **Beware Instrumentation Assumptions:** Initial guard offsets targeted the wrong stack slot due to MSVC’s `/GS` prolog. Always validate that instrumentation aligns with compiler-generated layouts.
3. **Automate Debugger Sessions:** Scripted cdb runs significantly sped up iteration and reduced manual error.
4. **Document Temporary Diagnostics:** Keeping a debugging journal made it easy to track instrumentation changes and clean them up afterward.
5. **Remove Temporary Code:** Once the bug is fixed, strip transient guards/logging to keep production code clean and maintainable.

## Next Steps
- (Optional) Re-run the full manual smoke suite on both Debug and Release to confirm no remaining regressions.
- Monitor future crashes; if new stack corruption appears, consider adding scoped guard utilities that can be toggled via debug builds.

