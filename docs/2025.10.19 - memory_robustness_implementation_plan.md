# Memory Robustness Implementation Plan (2025-10-19)

This plan operationalises `docs/2025.10.19 - memory_robustness_hld.md`. Each stage lists scope, prerequisites, validation, and follow-up tasks. Owners can be assigned during sprint planning.

## Stage 0 - Infrastructure Bootstrap
Scope:
- Scaffold `DebugMemoryGuard` (MSVC-only compilation).
- Implement rotating, thread-safe log writer under `%LOCALAPPDATA%\RailControl\Logs`.
- Add INI plumbing for `[Diagnostics] EnableMemoryGuards`.
- Author helper scripts `tools\enable_memory_guards.bat` and `tools\collect_minidump.ps1`.
- Document guard setup steps in `docs/development.md`.

Prerequisites:
- Confirm Windows SDK version available for `dbghelp`.
- Validate logging directory conventions.

Validation:
- Unit test log rotation with concurrent writers.
- Confirm Release (MSVC) and Borland builds exclude guard code.
- Run manual smoke checklist without guards enabled.

Follow-up:
- File backlog task for optional diagnostics UI integration of guard status.

## Stage 1 - Guard Diagnostics Integration
Scope:
- Implement enable/disable API, allocation tagging, and status query.
- Register vectored and unhandled exception handlers calling guard logger + `MiniDumpWriteDump`.
- Ship matching `dbghelp.dll` with debug artifacts.
- Add CI lint to ensure guard headers compile only under `_MSC_VER`.

Prerequisites:
- Stage 0 complete.
- Decide minidump output directory policy.

Validation:
- Force crash (debug build) to verify minidump + log creation and guard disable toggle.
- Lint job passes, confirming `_DEBUG` or `ENABLE_MEMORY_GUARDS` gating.

Follow-up:
- Measure guard performance overhead and note in documentation.

## Stage 2 - Ownership Refactor (Collections)
Scope:
- Introduce `TObjectArray<T>` with adapters for raw pointer access.
- Convert timetable and locomotive containers in `LAYOUT.CPP`, `LOCOYARD.CPP`, and related files.
- Add assertions guarding ownership transfer and document wrapper usage.
- Maintain Borland fallback (`#if !defined(_MSC_VER)`).
- Track adoption progress in `docs/development.md`.

Prerequisites:
- Stage 1 complete.
- Inventory modules currently using raw pointer arrays.

Validation:
- MSVC Debug/Release smoke runs pass.
- Borland build compiles without wrapper code.
- New regression tests exercise creation/destruction of timetable and loco entries.

Follow-up:
- Record remaining modules awaiting conversion.

## Stage 3 - Buffer Safety Conversion
Scope:
- Implement `CopyBuffer` helper and `TBuffer<N>` wrapper.
- Replace every parser/UI `CopyString` call with the new `CopyBuffer` helpers (and `TBuffer` where fixed arrays remain).
- Migrate high-risk comment/INI buffers to `std::string` or `owl::tstring` where APIs allow.
- Add fuzz-style `.RCD` ingestion harness (debug only).

Prerequisites:
- Stage 2 complete.
- Test harness scaffolding available.

Validation:
- Fuzz harness runs without guard alerts or assertions.
- Manual smoke checklist (file load, Game -> New) succeeds.
- Guard logs remain quiet in normal workflows.

Follow-up:
- Catalogue remaining fixed-size buffers for later remediation.

## Stage 4 - UI Resource Wrappers
Scope:
- Implement `THandleGuard` (and optional `TSharedHandle`) with custom deleters.
- Apply wrappers to GDI/HWND/HMENU resources in windows, toolbars, status bar, and dialogs.
- Audit timers and async callbacks for correct release semantics.

Prerequisites:
- Stage 2 complete.
- Map handle creation/destruction paths.

Validation:
- Manual UI smoke checklist with guards enabled confirms no leaks or double frees.
- Application Verifier (handles/heaps) passes.

Follow-up:
- Decide packaging for wrappers (shared header vs namespace).

## Stage 5 - Hardening and Automation
Scope:
- Enable PageHeap and Application Verifier in automated debug CI jobs.
- Publish troubleshooting guide and update smoke checklist with guard section.
- Add nightly guard-enabled automation that archives logs/dumps to `build\diagnostics\YYYYMMDD`.
- Implement multi-threaded allocation stress test verifying log rotation and dump behaviour.
- Enforce CI gate ensuring guard headers absent from release builds unless `ENABLE_MEMORY_GUARDS` defined.

Prerequisites:
- Stages 0-4 complete.
- CI pipeline approvals.

Validation:
- Nightly job generates expected artifacts and fails on guard alerts.
- Stress test passes without data races or log corruption.
- Release build audit confirms guard code excluded by default.

Follow-up:
- Schedule review of backlog items for remaining legacy patterns.
- Evaluate optional clang-cl ASan configuration once MSVC path stabilises.

## Stage 6 - Continuous Improvement (Ongoing)
Scope:
- Integrate guard status into diagnostics panel (optional).
- Extend fuzz harness to INI/timetable editing scenarios.
- Expand RAII adoption to remaining subsystems (routes, sections, platform data).
- Explore PageHeap/AppVerifier story for Borland toolchain, if feasible.

Validation:
- Maintain guard alert log with zero outstanding issues before each release.
- Periodic reviews of guard artifacts to identify regressions or recurring patterns.
