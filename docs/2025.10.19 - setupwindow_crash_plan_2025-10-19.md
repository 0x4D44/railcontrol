# SetupWindow Crash Follow-up Plan (2025-10-19)

> **Update â€“ 2025-10-19 09:12:** Guard instrumentation described below has been removed after fixing the `TLayout::StartNew` buffer bug. This document is kept for historical context only.

## Snapshot of current instrumentation
- RAILC.CPP:243 adds STACK_GUARD_CHECK and records gSetupWindowSavedEsi/gSetupWindowExpectedEsi so each milestone in TMainWindow::SetupWindow reports when the saved esi slot diverges.
- 	hird_party/owlcore/window.cpp:2594 mirrors the guard at the OWL base level via STACK_GUARD_CHECK_BASE, confirming the corruption occurs right after TFrameWindow::SetupWindow returns and before derived work executes.
- 	hird_party/owlcore/window.cpp:3058 labels each auto-created child with gSetupWindowGuardTag, keeping the guard output meaningful once we track the clobber.
- cdb_hw_watch.log shows mov dword ptr [ebp-0C4h], eax at TMainWindow::SetupWindow+0xDA6 writing the bad pointer that later becomes the bogus ToolbarHan value.
- Documentation updates in docs/debug_journal_2025-10-17.md and docs/progress_update_2025-10-18.md capture the guard behavior and outline the hardware-watch approach; the implementation is ready but the offending instruction is still unidentified.

## Immediate debugging steps
1. Launch cdb on the MSVC Debug build and stop at ailc_msvc!TMainWindow::SetupWindow.
   - p railc_msvc!TMainWindow::SetupWindow then g to break on entry.
   -  @ = poi(railc_msvc!gSetupWindowSavedEsi) to cache the tracked stack address.
   - a w4 @ to arm a hardware watch on the saved esi slot.
   - c *; bp railc_msvc!TMainWindow::SetupWindow+0xDA6; g to confirm the known bad write still fires, then l to ensure the a is active before rerunning from entry.
2. When the hardware breakpoint triggers earlier, dump context to identify the last writer to [ebp-0xC4].
   - Collect kv, ub eip-20, and  eax,ebx,ecx,edx,esi,edi.
   - Use ln eip and uf around the owning function to map the store back to source in 	hird_party/owlcore or RAILC.CPP.
   - Add the findings to cdb_hw_watch.log with a new timestamped section.

## Source code audit targets once the writer is known
- Review the loop or helper responsible for the clobber. Primary suspects:
  - Toolbar setup: verify TMainWindow::SetupWindow uses indices 1..12 within the Toolbuttondata buffers sized for 20 entries; double-check TToolbar::SetupWindow and TToolbutton::TToolbutton to ensure no off-by-one writes during control creation.
  - Platform/arrival window data: inspect any memcpy/strcpy-like helpers invoked before the guard trip, especially code in RAILC.CPP and PLATFORM.CPP that may still execute during initial window setup.
  - OWL base helpers called from TFrameWindow::SetupWindow (menu initialization, client rect adjustments, tooltip provisioning) for mismatched calling conventions or buffer lengths.
- If the culprit is in OWL, compare with the Borland-built binary or upstream OWLNext 6.30 sources to confirm whether our local tree diverged.
- Add targeted assertions (temporarily) around the suspect code to verify parameters before applying any permanent fix.

## Mitigation and validation
1. Implement a bounded fix (e.g., adjust loop limits, correct buffer sizes, or align calling conventions) in the offending module.
2. Rebuild the MSVC Debug target and rerun the guard sequence to ensure gSetupWindowGuardTag stays at "after base SetupWindow" with no mismatches.
3. Repeat the run under Borland via uild.bat to confirm the legacy toolchain survives the change.
4. Execute the manual smoke checklist: launch ailc_msvc.exe, open each major window, load every sample .RCD, and invoke F1 help.
5. Once stable, remove or #if 0 the guard instrumentation, leaving behind only doc updates (docs/debug_journal_2025-10-17.md) summarizing the root cause and fix.

## Documentation follow-ups
- Append the investigation results, fix description, and validation evidence to docs/debug_journal_2025-10-17.md.
- Update progress_summary_runtime.txt with the final status of the startup crash.
- If the large edit to RESOURCE/RAILC.RC was incidental to debugging, confirm whether it should stay or be reverted before submitting the final patch.
